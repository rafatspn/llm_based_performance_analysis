idx,code,gold_label,pred_raw,pred_norm,correct,explanation
0,"// A Divide and Conquer Program to find maximum rectangular area in a histogram
#include <bits/stdc++.h>
using namespace std;
  
// A utility function to find minimum of three integers
int max(int x, int y, int z)
{  return max(max(x, y), z); }
  
// A utility function to get minimum of two numbers in hist[]
int minVal(int *hist, int i, int j)
{
    if (i == -1) return j;
    if (j == -1) return i;
    return (hist[i] < hist[j])? i : j;
}
  
// A utility function to get the middle index from corner indexes.
int getMid(int s, int e)
{   return s + (e -s)/2; }
  
/*  A recursive function to get the index of minimum value in a given range of
    indexes. The following are parameters for this function.
  
    hist   --> Input array for which segment tree is built
    st    --> Pointer to segment tree
    index --> Index of current node in the segment tree. Initially 0 is
             passed as root is always at index 0
    ss & se  --> Starting and ending indexes of the segment represented by
                 current node, i.e., st[index]
    qs & qe  --> Starting and ending indexes of query range */
int RMQUtil(int *hist, int *st, int ss, int se, int qs, int qe, int index)
{
    // If segment of this node is a part of given range, then return the
    // min of the segment
    if (qs <= ss && qe >= se)
        return st[index];
  
    // If segment of this node is outside the given range
    if (se < qs || ss > qe)
        return -1;
  
    // If a part of this segment overlaps with the given range
    int mid = getMid(ss, se);
    return minVal(hist, RMQUtil(hist, st, ss, mid, qs, qe, 2*index+1),
                  RMQUtil(hist, st, mid+1, se, qs, qe, 2*index+2));
}
  
// Return index of minimum element in range from index qs (query start) to
// qe (query end).  It mainly uses RMQUtil()
int RMQ(int *hist, int *st, int n, int qs, int qe)
{
    // Check for erroneous input values
    if (qs < 0 || qe > n-1 || qs > qe)
    {
        cout << ""Invalid Input"";
        return -1;
    }
  
    return RMQUtil(hist, st, 0, n-1, qs, qe, 0);
}
  
// A recursive function that constructs Segment Tree for hist[ss..se].
// si is index of current node in segment tree st
int constructSTUtil(int hist[], int ss, int se, int *st, int si)
{
    // If there is one element in array, store it in current node of
    // segment tree and return
    if (ss == se)
       return (st[si] = ss);
  
    // If there are more than one elements, then recur for left and
    // right subtrees and store the minimum of two values in this node
    int mid = getMid(ss, se);
    st[si] =  minVal(hist, constructSTUtil(hist, ss, mid, st, si*2+1),
                     constructSTUtil(hist, mid+1, se, st, si*2+2));
    return st[si];
}
  
/* Function to construct segment tree from given array. This function
   allocates memory for segment tree and calls constructSTUtil() to
   fill the allocated memory */
int *constructST(int hist[], int n)
{
    // Allocate memory for segment tree
    int x = (int)(ceil(log2(n))); //Height of segment tree
    int max_size = 2*(int)pow(2, x) - 1; //Maximum size of segment tree
    int *st = new int[max_size];
  
    // Fill the allocated memory st
    constructSTUtil(hist, 0, n-1, st, 0);
  
    // Return the constructed segment tree
    return st;
}
  
// A recursive function to find the maximum rectangular area.
// It uses segment tree 'st' to find the minimum value in hist[l..r]
int getMaxAreaRec(int *hist, int *st, int n, int l, int r)
{
    // Base cases
    if (l > r)  return INT_MIN;
    if (l == r)  return hist[l];
  
    // Find index of the minimum value in given range
    // This takes O(Logn)time
    int m = RMQ(hist, st, n, l, r);
  
    /* Return maximum of following three possible cases
       a) Maximum area in Left of min value (not including the min)
       a) Maximum area in right of min value (not including the min)
       c) Maximum area including min */
    return max(getMaxAreaRec(hist, st, n, l, m-1),
               getMaxAreaRec(hist, st, n, m+1, r),
               (r-l+1)*(hist[m]) );
}
  
// The main function to find max area
int getMaxArea(int hist[], int n)
{
    // Build segment tree from given array. This takes
    // O(n) time
    int *st = constructST(hist, n);
  
    // Use recursive utility function to find the
    // maximum area
    return getMaxAreaRec(hist, st, n, 0, n-1);
}
  
// Driver program to test above functions
int main()
{
    int hist[] =  {6, 1, 5, 4, 5, 2, 6};
    int n = sizeof(hist)/sizeof(hist[0]);
    cout << ""Maximum area is "" << getMaxArea(hist, n);
    return 0;
}",nlogn,nlogn,nlogn,1,nlogn
1,"// Given a binary matrix of M X N of integers,
// you need to return only unique rows of binary array
#include <bits/stdc++.h>
using namespace std;
#define ROW 4
#define COL 5
 
// The main function that prints
// all unique rows in a given matrix.
void findUniqueRows(int M[ROW][COL])
{
    //Traverse through the matrix
    for(int i=0; i<ROW; i++)
    {
        int flag=0;
         
        //check if there is similar column
        //is already printed, i.e if i and
        //jth column match.
        for(int j=0; j<i; j++)
        {
            flag=1;
             
            for(int k=0; k<=COL; k++)
            if(M[i][k]!=M[j][k])
                flag=0;
             
            if(flag==1)
            break;
        }
         
        //if no row is similar
        if(flag==0)
        {
            //print the row
            for(int j=0; j<COL; j++)
                cout<<M[i][j]<<"" "";
            cout<<endl;
        }
    }
}
 
// Driver Code
int main()
{
    int M[ROW][COL] = {{0, 1, 0, 0, 1},
                       {1, 0, 1, 1, 0},
                       {0, 1, 0, 0, 1},
                       {1, 0, 1, 0, 0}};
 
    findUniqueRows(M);
 
    return 0;
}",cubic,quadratic,quadratic,0,quadratic
2,"// Given a binary matrix of M X N of integers,
// you need to return only unique rows of binary array
#include <bits/stdc++.h>
using namespace std;
#define ROW 4
#define COL 5
 
class BST
{
    int data;
    BST *left, *right;
 
    public:
     
    // Default constructor.
    BST();
     
    // Parameterized constructor.
    BST(int);
     
    // Insert function.
    BST* Insert(BST *, int);
     
    // Inorder traversal.
    void Inorder(BST *);
};
 
//convert array to decimal
int convert(int arr[])
{
    int sum=0;
     
    for(int i=0; i<COL; i++)
    {
        sum+=pow(2,i)*arr[i];
    }
    return sum;
}
 
//print the column represented as integers
void print(int p)
{
    for(int i=0; i<COL; i++)
    {
        cout<<p%2<<"" "";
        p/=2;
    }
    cout<<endl;
}
 
 
// Default Constructor definition.
BST :: BST() : data(0), left(NULL), right(NULL){}
 
// Parameterized Constructor definition.
BST :: BST(int value)
{
    data = value;
    left = right = NULL;
}
 
// Insert function definition.
BST* BST :: Insert(BST *root, int value)
{
    if(!root)
    {
        // Insert the first node, if root is NULL.
        return new BST(value);
    }
     
    //if the value is present
    if(value == root->data)
     return root;
 
    // Insert data.
    if(value > root->data)
    {
        // Insert right node data, if the 'value'
        // to be inserted is greater than 'root' node data.
         
        // Process right nodes.
        root->right = Insert(root->right, value);
    }
    else
    {
        // Insert left node data, if the 'value'
        // to be inserted is greater than 'root' node data.
         
        // Process left nodes.
        root->left = Insert(root->left, value);
    }
     
    // Return 'root' node, after insertion.
    return root;
}
 
// Inorder traversal function.
// This gives data in sorted order.
void BST :: Inorder(BST *root)
{
    if(!root)
    {
        return;
    }
    Inorder(root->left);
    print( root->data );
    Inorder(root->right);
}
 
 
// The main function that prints
// all unique rows in a given matrix.
void findUniqueRows(int M[ROW][COL])
{
     
    BST b, *root = NULL;
     
    //Traverse through the matrix
    for(int i=0; i<ROW; i++)
    {
        //insert the row into BST
        root=b.Insert(root,convert(M[i]));
    }
     
     
    //print
    b.Inorder(root);
     
}
 
// Driver Code
int main()
{
    int M[ROW][COL] = {{0, 1, 0, 0, 1},
                       {1, 0, 1, 1, 0},
                       {0, 1, 0, 0, 1},
                       {1, 0, 1, 0, 0}};
 
    findUniqueRows(M);
 
    return 0;
}",quadratic,nlogn,nlogn,0,nlogn
3,"// Given a binary matrix of M X N of integers,
// you need to return only unique rows of binary array
#include <bits/stdc++.h>
using namespace std;
#define ROW 4
#define COL 5
 
// A Trie node
class Node
{
    public:
    bool isEndOfCol;
    Node *child[2]; // Only two children needed for 0 and 1
} ;
 
 
// A utility function to allocate memory
// for a new Trie node
Node* newNode()
{
    Node* temp = new Node();
    temp->isEndOfCol = 0;
    temp->child[0] = temp->child[1] = NULL;
    return temp;
}
 
// Inserts a new matrix row to Trie.
// If row is already present,
// then returns 0, otherwise insets the row and
// return 1
bool insert(Node** root, int (*M)[COL],
                int row, int col )
{
    // base case
    if (*root == NULL)
        *root = newNode();
 
    // Recur if there are more entries in this row
    if (col < COL)
        return insert (&((*root)->child[M[row][col]]),
                                        M, row, col + 1);
 
    else // If all entries of this row are processed
    {
        // unique row found, return 1
        if (!((*root)->isEndOfCol))
            return (*root)->isEndOfCol = 1;
 
        // duplicate row found, return 0
        return 0;
    }
}
 
// A utility function to print a row
void printRow(int(*M)[COL], int row)
{
    int i;
    for(i = 0; i < COL; ++i)
        cout << M[row][i] << "" "";
    cout << endl;
}
 
// The main function that prints
// all unique rows in a given matrix.
void findUniqueRows(int (*M)[COL])
{
    Node* root = NULL; // create an empty Trie
    int i;
 
    // Iterate through all rows
    for (i = 0; i < ROW; ++i)
     
        // insert row to TRIE
        if (insert(&root, M, i, 0))
         
            // unique row found, print it
            printRow(M, i);
}
 
// Driver Code
int main()
{
    int M[ROW][COL] = {{0, 1, 0, 0, 1},
                       {1, 0, 1, 1, 0},
                       {0, 1, 0, 0, 1},
                       {1, 0, 1, 0, 0}};
 
    findUniqueRows(M);
 
    return 0;
}
 
// This code is contributed by rathbhupendra",quadratic,nlogn,nlogn,0,nlogn
4,"// A Simple C++ O(n^3)  program to count inversions of size 3
#include<bits/stdc++.h>
using namespace std;
 
// Returns counts of inversions of size three
int getInvCount(int arr[],int n)
{
    int invcount = 0;  // Initialize result
 
    for (int i=0; i<n-2; i++)
    {
        for (int j=i+1; j<n-1; j++)
        {
            if (arr[i]>arr[j])
            {
                for (int k=j+1; k<n; k++)
                {
                    if (arr[j]>arr[k])
                        invcount++;
                }
            }
        }
    }
    return invcount;
}
 
// Driver program to test above function
int main()
{
    int arr[] = {8, 4, 2, 1};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << ""Inversion Count : "" << getInvCount(arr, n);
    return 0;
}",cubic,nlogn,nlogn,0,nlogn
5,"// Search an element in sorted and rotated
// array using single pass of Binary Search
#include <bits/stdc++.h>
using namespace std;
 
// Returns index of key in arr[l..h] if
// key is present, otherwise returns -1
int search(int arr[], int l, int h, int key)
{
    if (l > h)
        return -1;
 
    int mid = (l + h) / 2;
    if (arr[mid] == key)
        return mid;
 
    /* If arr[l...mid] is sorted */
    if (arr[l] <= arr[mid]) {
        /* As this subarray is sorted, we can quickly
        check if key lies in half or other half */
        if (key >= arr[l] && key <= arr[mid])
            return search(arr, l, mid - 1, key);
        /*If key not lies in first half subarray,
           Divide other half  into two subarrays,
           such that we can quickly check if key lies
           in other half */
        return search(arr, mid + 1, h, key);
    }
 
    /* If arr[l..mid] first subarray is not sorted, then
    arr[mid... h] must be sorted subarray */
    if (key >= arr[mid] && key <= arr[h])
        return search(arr, mid + 1, h, key);
 
    return search(arr, l, mid - 1, key);
}
 
// Driver program
int main()
{
    int arr[] = { 4, 5, 6, 7, 8, 9, 1, 2, 3 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int key = 3;
    int i = search(arr, 0, n - 1, key);
 
    if (i != -1)
        cout << ""Index: "" << i << endl;
    else
        cout << ""Key not found"";
}
 
// This code is contributed by Aditya Kumar (adityakumar129)",logn,n,linear,0,n
6,"// C++ program to Rearrange positive and negative
// numbers in a array
#include <iostream>
using namespace std;
 
/* Function to print an array */
void printArray(int A[], int size)
{
    for (int i = 0; i < size; i++)
        cout << A[i] << "" "";
    cout << endl;
}
 
// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;
 
    /* create temp arrays */
    int L[n1], R[n2];
 
    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
 
    /* Merge the temp arrays back into arr[l..r]*/
    i = 0; // Initial index of first subarray
    j = 0; // Initial index of second subarray
    k = l; // Initial index of merged subarray
 
    // Note the order of appearance of elements should
    // be maintained - we copy elements of left subarray
    // first followed by that of right subarray
 
    // copy negative elements of left subarray
    while (i < n1 && L[i] < 0)
        arr[k++] = L[i++];
 
    // copy negative elements of right subarray
    while (j < n2 && R[j] < 0)
        arr[k++] = R[j++];
 
    // copy positive elements of left subarray
    while (i < n1)
        arr[k++] = L[i++];
 
    // copy positive elements of right subarray
    while (j < n2)
        arr[k++] = R[j++];
}
 
// Function to Rearrange positive and negative
// numbers in a array
void RearrangePosNeg(int arr[], int l, int r)
{
    if (l < r) {
        // Same as (l + r)/2, but avoids overflow for
        // large l and h
        int m = l + (r - l) / 2;
 
        // Sort first and second halves
        RearrangePosNeg(arr, l, m);
        RearrangePosNeg(arr, m + 1, r);
 
        merge(arr, l, m, r);
    }
}
 
/* Driver program to test above functions */
int main()
{
    int arr[] = { -12, 11, -13, -5, 6, -7, 5, -3, -6 };
    int arr_size = sizeof(arr) / sizeof(arr[0]);
 
    RearrangePosNeg(arr, 0, arr_size - 1);
 
    printArray(arr, arr_size);
 
    return 0;
}",nlogn,quadratic,quadratic,0,quadratic
7,"// C++ program of the above
// approach
 
#include <iostream>
using namespace std;
 
// Function to shift all the
// negative elements on left side
void shiftall(int arr[], int left,
              int right)
{
   
  // Loop to iterate over the
  // array from left to the right
  while (left<=right)
  {
    // Condition to check if the left
    // and the right elements are
    // negative
    if (arr[left] < 0 && arr[right] < 0)
      left+=1;
     
    // Condition to check if the left
    // pointer element is positive and
    // the right pointer element is negative
    else if (arr[left]>0 && arr[right]<0)
    {
      int temp=arr[left];
      arr[left]=arr[right];
      arr[right]=temp;
      left+=1;
      right-=1;
    }
     
    // Condition to check if both the
    // elements are positive
    else if (arr[left]>0 && arr[right] >0)
      right-=1;
    else{
      left += 1;
      right -= 1;
    }
  }
}
 
// Function to print the array
void display(int arr[], int right){
   
  // Loop to iterate over the element
  // of the given array
  for (int i=0;i<=right;++i){
    cout<<arr[i]<<"" "";
  }
  cout<<endl;
}
 
// Driver Code
int main()
{
  int arr[] = {-12, 11, -13, -5,
               6, -7, 5, -3, 11};
  int arr_size = sizeof(arr) /
                sizeof(arr[0]);
   
  // Function Call
  shiftall(arr,0,arr_size-1);
  display(arr,arr_size-1);
  return 0;
}
 
//added by Dhruv Goyal",linear,quadratic,quadratic,0,quadratic
8,"// C++ program to find maximum
// in arr[] of size n
#include <bits/stdc++.h>
using namespace std;
  
int largest(int arr[], int n, int i)
{
    // last index
    // return the element
    if (i == n - 1) {
        return arr[i];
    }
  
    // find the maximum from rest of the array
    int recMax = largest(arr, n, i + 1);
  
    // compare with i-th element and return
    return max(recMax, arr[i]);
}
  
// Driver Code
int main()
{
    int arr[] = { 10, 324, 45, 90, 9808 };
    int n = sizeof(arr) / sizeof(arr[0]);
    cout << ""Largest in given array is ""
         << largest(arr, n, 0);
    return 0;
}
  
// This Code is contributed by Rajdeep Mallick",linear,quadratic,quadratic,0,quadratic
9,"// C++ program to find med in
// stream of running integers
#include<bits/stdc++.h>
using namespace std;
  
// function to calculate med of stream
void printMedians(double arr[], int n)
{
    // max heap to store the smaller half elements
    priority_queue<double> s;
  
    // min heap to store the greater half elements
    priority_queue<double,vector<double>,greater<double> > g;
  
    double med = arr[0];
    s.push(arr[0]);
  
    cout << med << endl;
  
    // reading elements of stream one by one
    /*  At any time we try to make heaps balanced and
        their sizes differ by at-most 1. If heaps are
        balanced,then we declare median as average of
        min_heap_right.top() and max_heap_left.top()
        If heaps are unbalanced,then median is defined
        as the top element of heap of larger size  */
    for (int i=1; i < n; i++)
    {
        double x = arr[i];
  
        // case1(left side heap has more elements)
        if (s.size() > g.size())
        {
            if (x < med)
            {
                g.push(s.top());
                s.pop();
                s.push(x);
            }
            else
                g.push(x);
  
            med = (s.top() + g.top())/2.0;
        }
  
        // case2(both heaps are balanced)
        else if (s.size()==g.size())
        {
            if (x < med)
            {
                s.push(x);
                med = (double)s.top();
            }
            else
            {
                g.push(x);
                med = (double)g.top();
            }
        }
  
        // case3(right side heap has more elements)
        else
        {
            if (x > med)
            {
                s.push(g.top());
                g.pop();
                g.push(x);
            }
            else
                s.push(x);
  
            med = (s.top() + g.top())/2.0;
        }
  
        cout << med << endl;
    }
}
  
// Driver program to test above functions
int main()
{
    // stream of integers
    double arr[] = {5, 15, 10, 20, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    printMedians(arr, n);
    return 0;
}",nlogn,nlogn,nlogn,1,nlogn
10,"// C++ implementation to find k numbers with most
// occurrences in the given array
#include <bits/stdc++.h>
using namespace std;
 
// Comparison function to sort the 'freq_arr[]'
bool compare(pair<int, int> p1, pair<int, int> p2)
{
    // If frequencies of two elements are same
    // then the larger number should come first
    if (p1.second == p2.second)
        return p1.first > p2.first;
 
    // Sort on the basis of decreasing order
    // of frequencies
    return p1.second > p2.second;
}
 
// Function to print the k numbers with most occurrences
void print_N_mostFrequentNumber(int arr[], int N, int K)
{
    // unordered_map 'mp' implemented as frequency hash
    // table
    unordered_map<int, int> mp;
    for (int i = 0; i < N; i++)
        mp[arr[i]]++;
 
    // store the elements of 'mp' in the vector 'freq_arr'
    vector<pair<int, int> > freq_arr(mp.begin(), mp.end());
 
    // Sort the vector 'freq_arr' on the basis of the
    // 'compare' function
    sort(freq_arr.begin(), freq_arr.end(), compare);
 
    // display the top k numbers
    cout << K << "" numbers with most occurrences are:\n"";
    for (int i = 0; i < K; i++)
        cout << freq_arr[i].first << "" "";
}
 
// Driver's code
int main()
{
    int arr[] = { 3, 1, 4, 4, 5, 2, 6, 1 };
    int N = sizeof(arr) / sizeof(arr[0]);
    int K = 2;
 
    // Function call
    print_N_mostFrequentNumber(arr, N, K);
 
    return 0;
}",nlogn,n,linear,0,n
11,"//C++ program for the above approach
#include <bits/stdc++.h>
 
using namespace std;
 
// Program to find missing element
int findFirstMissing(vector<int> arr , int start ,
                        int  end,int first)
{
 
  if (start < end)
  {
    int mid = (start + end) / 2;
 
    /** Index matches with value
      at that index, means missing
      element cannot be upto that po*/
    if (arr[mid] != mid+first)
      return findFirstMissing(arr, start,
                                 mid , first);
    else
      return findFirstMissing(arr, mid + 1,
                                 end , first);
  }
  return start + first;
 
}
 
// Program to find Smallest
// Missing in Sorted Array
int findSmallestMissinginSortedArray(vector<int> arr)
{
   
  // Check if 0 is missing
  // in the array
  if(arr[0] != 0)
    return 0;
 
  // Check is all numbers 0 to n - 1
  // are present in array
  if(arr[arr.size() - 1] == arr.size() - 1)
    return arr.size();
 
  int first = arr[0];
 
  return findFirstMissing(arr, 0, arr.size() - 1, first);
}
 
 
// Driver program to test the above function
int main()
{
    vector<int> arr = {0, 1, 2, 3, 4, 5, 7};
    int n = arr.size();
 
    // Function Call
    cout<<""First Missing element is : ""<<findSmallestMissinginSortedArray(arr);
}
 
// This code is contributed by mohit kumar 29.",logn,quadratic,quadratic,0,quadratic
12,"// CPP program to perform range queries over range
// queries.
#include <bits/stdc++.h>
#define max 10000
using namespace std;
 
// For prefix sum array
void update(int arr[], int l)
{
    arr[l] += arr[l - 1];
}
 
// This function is used to apply square root
// decomposition in the record array
void record_func(int block_size, int block[],
         int record[], int l, int r, int value)
{
    // traversing first block in range
    while (l < r && l % block_size != 0 && l != 0) {
        record[l] += value;
        l++;
    }
    // traversing completely overlapped blocks in range
    while (l + block_size <= r + 1) {
        block[l / block_size] += value;
        l += block_size;
    }
    // traversing last block in range
    while (l <= r) {
        record[l] += value;
        l++;
    }
}
// Function to print the resultant array
void print(int arr[], int n)
{
    for (int i = 0; i < n; i++)
        cout << arr[i] << "" "";   
}
 
// Driver code
int main()
{
    int n = 5, m = 5;
    int arr[n], record[m];
    int block_size = sqrt(m);
    int block[max];
    int command[5][3] = { { 1, 1, 2 }, { 1, 4, 5 },
                          { 2, 1, 2 }, { 2, 1, 3 },
                          { 2, 3, 4 } };
    memset(arr, 0, sizeof arr);
    memset(record, 0, sizeof record);
    memset(block, 0, sizeof block);
 
    for (int i = m - 1; i >= 0; i--) {
 
        // If query is of type 2 then function
        // call to record_func
        if (command[i][0] == 2) {
            int x = i / (block_size);
            record_func(block_size, block, record,
                        command[i][1] - 1, command[i][2] - 1,
                        (block[x] + record[i] + 1));
        }
        // If query is of type 1 then simply add
        // 1 to the record array
        else
            record[i]++;       
    }
 
    // Merging the value of the block in the record array
    for (int i = 0; i < m; i++) {
        int check = (i / block_size);
        record[i] += block[check];
    }
 
    for (int i = 0; i < m; i++) {
        // If query is of type 1 then the array
        // elements are over-written by the record
        //  array
        if (command[i][0] == 1) {
            arr[command[i][1] - 1] += record[i];
            if ((command[i][2] - 1) < n - 1)
                arr[(command[i][2])] -= record[i];           
        }
    }
 
    // The prefix sum of the array
    for (int i = 1; i < n; i++)
        update(arr, i);
     
    // Printing the resultant array
    print(arr, n);
    return 0;
}",logn,quadratic,quadratic,0,quadratic
13,"// C++ program to find Minimum
// number of jumps to reach end
#include <bits/stdc++.h>
using namespace std;
 
// Function to return the minimum number
// of jumps to reach arr[h] from arr[l]
int minJumps(int arr[], int n)
{
 
    // Base case: when source and
    // destination are same
    if (n == 1)
        return 0;
 
    // Traverse through all the points
    // reachable from arr[l]
    // Recursively, get the minimum number
    // of jumps needed to reach arr[h] from
    // these reachable points
    int res = INT_MAX;
    for (int i = n - 2; i >= 0; i--) {
        if (i + arr[i] >= n - 1) {
            int sub_res = minJumps(arr, i + 1);
            if (sub_res != INT_MAX)
                res = min(res, sub_res + 1);
        }
    }
 
    return res;
}
 
// Driver Code
int main()
{
    int arr[] = { 1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9 };
    int n = sizeof(arr) / sizeof(arr[0]);
    cout << ""Minimum number of jumps to"";
    cout << "" reach the end is "" << minJumps(arr, n);
    return 0;
}
 
// This code is contributed
// by Shivi_Aggarwal",np,n,linear,0,n
14,"// C++ program to find the smallest positive value that cannot be
// represented as sum of subsets of a given sorted array
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
 
// Returns the smallest number that cannot be represented as sum
// of subset of elements from set represented by sorted array arr[0..n-1]
long long smallestpositive(vector<long long> arr, int n) {
   long long int res = 1; // Initialize result
  
   sort(arr.begin(), arr.end());
   // Traverse the array and increment 'res' if arr[i] is
   // smaller than or equal to 'res'.
   for (int i = 0; i < n && arr[i] <= res; i++)
       res = res + arr[i];
  
   return res;
  }
 
// Driver program to test above function
int main() {
   vector<long long> arr1 = {1, 3, 4, 5};
   cout << smallestpositive(arr1, arr1.size()) << endl;
  
   vector<long long> arr2 = {1, 2, 6, 10, 11, 15};
   cout << smallestpositive(arr2, arr2.size()) << endl;
  
   vector<long long> arr3 = {1, 1, 1, 1};
   cout << smallestpositive(arr3, arr3.size()) << endl;
  
   vector<long long> arr4 = {1, 1, 3, 4};
   cout << smallestpositive(arr4, arr4.size()) << endl;
  
   return 0;
 }",nlogn,n,linear,0,n
15,"// CPP program for above approach
#include <bits/stdc++.h>
using namespace std;
 
// Compare function
bool fcompare(pair<int, pair<int, int> > p,
              pair<int, pair<int, int> > p1)
{
    if (p.second.second != p1.second.second)
        return (p.second.second > p1.second.second);
    else
        return (p.second.first < p1.second.first);
}
void sortByFrequency(int arr[], int n)
{
    unordered_map<int, pair<int, int> > hash; // hash map
    for (int i = 0; i < n; i++) {
        if (hash.find(arr[i]) != hash.end())
            hash[arr[i]].second++;
        else
            hash[arr[i]] = make_pair(i, 1);
    } // store the count of all the elements in the hashmap
 
    // Iterator to Traverse the Hashmap
    auto it = hash.begin();
 
    // Vector to store the Final Sortted order
    vector<pair<int, pair<int, int> > > b;
    for (it; it != hash.end(); ++it)
        b.push_back(make_pair(it->first, it->second));
 
    sort(b.begin(), b.end(), fcompare);
 
    // Printing the Sorted sequence
    for (int i = 0; i < b.size(); i++) {
        int count = b[i].second.second;
        while (count--)
            cout << b[i].first << "" "";
    }
}
 
// Driver code
int main()
{
    int arr[] = { 2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8 };
    int n = sizeof(arr) / sizeof(arr[0]);
 
    // Function call
    sortByFrequency(arr, n);
 
    return 0;
}",nlogn,quadratic,quadratic,0,quadratic
16,"// C++ program to find
// minimum number of swaps
// required to sort an array
#include<bits/stdc++.h>
using namespace std;
 
void swap(vector<int> &arr,
          int i, int j)
{
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
// Return the minimum number
// of swaps required to sort
// the array
int minSwaps(vector<int>arr,
             int N)
{
  int ans = 0;
  vector<int>temp = arr;
 
  // Hashmap which stores the
  // indexes of the input array
  map <int, int> h;
 
  sort(temp.begin(), temp.end());
  for (int i = 0; i < N; i++)
  {
    h[arr[i]] = i;
  }
  for (int i = 0; i < N; i++)
  {
    // This is checking whether
    // the current element is
    // at the right place or not
    if (arr[i] != temp[i])
    {
      ans++;
      int init = arr[i];
 
      // If not, swap this element
      // with the index of the
      // element which should come here
      swap(arr, i, h[temp[i]]);
 
      // Update the indexes in
      // the hashmap accordingly
      h[init] = h[temp[i]];
      h[temp[i]] = i;
    }
  }
  return ans;
}
 
// Driver class
int main()
{
  // Driver program to
  // test the above function
  vector <int> a = {101, 758, 315,
                    730, 472, 619,
                    460, 479};
  int n = a.size();
   
  // Output will be 5
  cout << minSwaps(a, n);
}
 
// This code is contributed by Stream_Cipher",nlogn,n,linear,0,n
17,"#include <bits/stdc++.h>
using namespace std;
 
int BS(int arr[], int X, int low, int N)
{
    int high = N - 1;
    int ans = N;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] >= X) {
            ans = mid;
            high = mid - 1;
        }
        else
            low = mid + 1;
    }
    return ans;
}
int countPairsWithDiffK(int arr[], int N, int k)
{
    int count = 0;
    sort(arr, arr + N);
    for (int i = 0; i < N; ++i) {
        int X = BS(arr, arr[i] + k, i + 1, N);
        if (X != N) {
            int Y = BS(arr, arr[i] + k + 1, i + 1, N);
            count += Y - X;
        }
    }
 
    return count;
}
int main()
{
    int arr[] = { 1, 3, 5, 8, 6, 4, 6 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 2;
    cout << ""Count of pairs with given diff is ""
         << countPairsWithDiffK(arr, n, k);
 
    return 0;
}
 
// This code is contributed by umadevi9616",nlogn,nlogn,nlogn,1,nlogn
18,"// C++ program to implement insert
// operation in an unsorted array.
#include <iostream>
using namespace std;
 
// Inserts a key in arr[] of given capacity.
// n is current size of arr[]. This
// function returns n + 1 if insertion
// is successful, else n.
int insertSorted(int arr[], int n, int key, int capacity)
{
 
    // Cannot insert more elements if n is
    // already more than or equal to capacity
    if (n >= capacity)
        return n;
 
    arr[n] = key;
 
    return (n + 1);
}
 
// Driver Code
int main()
{
    int arr[20] = { 12, 16, 20, 40, 50, 70 };
    int capacity = sizeof(arr) / sizeof(arr[0]);
    int n = 6;
    int i, key = 26;
 
    cout << ""\n Before Insertion: "";
    for (i = 0; i < n; i++)
        cout << arr[i] << "" "";
 
    // Inserting key
    n = insertSorted(arr, n, key, capacity);
 
    cout << ""\n After Insertion: "";
    for (i = 0; i < n; i++)
        cout << arr[i] << "" "";
 
    return 0;
}
 
// This code is contributed by SHUBHAMSINGH10",constant,quadratic,quadratic,0,quadratic
19,"// C++ program to implement binary search in sorted array
#include <bits/stdc++.h>
using namespace std;
 
int binarySearch(int arr[], int low, int high, int key)
{
    if (high < low)
        return -1;
    int mid = (low + high) / 2; /*low + (high - low)/2;*/
    if (key == arr[mid])
        return mid;
    if (key > arr[mid])
        return binarySearch(arr, (mid + 1), high, key);
    return binarySearch(arr, low, (mid - 1), key);
}
 
/* Driver code */
int main()
{
    // Let us search 3 in below array
    int arr[] = { 5, 6, 7, 8, 9, 10 };
    int n, key;
 
    n = sizeof(arr) / sizeof(arr[0]);
    key = 10;
 
    // Function call
    cout << ""Index: "" << binarySearch(arr, 0, n - 1, key)
         << endl;
    return 0;
}
 
// This code is contributed by NamrataSrivastava1",logn,quadratic,quadratic,0,quadratic
20,"// C++ program to find the only repeating
// element in an array where elements are
// from 1 to N-1.
 
#include <bits/stdc++.h>
using namespace std;
 
int findRepeating(int arr[], int N)
{
    unordered_set<int> s;
    for (int i = 0; i < N; i++) {
        if (s.find(arr[i]) != s.end())
            return arr[i];
        s.insert(arr[i]);
    }
 
    // If input is correct, we should
    // never reach here
    return -1;
}
 
// Driver's code
int main()
{
    int arr[] = { 9, 8, 2, 6, 1, 8, 5, 3, 4, 7 };
    int N = sizeof(arr) / sizeof(arr[0]);
   
      // Function call
    cout << findRepeating(arr, N);
    return 0;
}",linear,quadratic,quadratic,0,quadratic
21,"// C++ implementation of above approach
#include <bits/stdc++.h>
using namespace std;
 
/* Function to get index of ceiling of x in arr[low..high] */
int ceilSearch(int arr[], int low, int high, int x)
{
     
    int i;
     
    /* If x is smaller than or equal to first element,
        then return the first element */
    if(x <= arr[low])
        return low;
     
    /* Otherwise, linearly search for ceil value */
    for(i = low; i < high; i++)
    {
        if(arr[i] == x)
        return i;
     
        /* if x lies between arr[i] and arr[i+1] including
        arr[i+1], then return arr[i+1] */
        if(arr[i] < x && arr[i+1] >= x)
        return i+1;
    }    
     
    /* If we reach here then x is greater than the last element
        of the array, return -1 in this case */
    return -1;
}
 
 
/* Driver code*/
int main()
{
    int arr[] = {1, 2, 8, 10, 10, 12, 19};
    int n = sizeof(arr)/sizeof(arr[0]);
    int x = 3;
    int index = ceilSearch(arr, 0, n-1, x);
    if(index == -1)
        cout << ""Ceiling of "" << x << "" doesn't exist in array "";
    else
        cout << ""ceiling of "" << x << "" is "" << arr[index];
     
    return 0;
}
 
// This is code is contributed by rathbhupendra",linear,n,linear,1,n
22,"// A C++ program to find a peak element
// using divide and conquer
#include <bits/stdc++.h>
using namespace std;
 
// A binary search based function
// that returns index of a peak element
int findPeak(int arr[], int n)
{
    int l = 0;
    int r = n-1;
    int mid;
   
    while (l <= r) {
       
        // finding mid by binary right shifting.
        mid = (l + r) >> 1;
       
        // first case if mid is the answer
        if ((mid == 0 || arr[mid - 1] <= arr[mid])
            and (mid == n - 1 || arr[mid + 1] <= arr[mid]))
            break;
       
        // move the right pointer
        if (mid > 0 and arr[mid - 1] > arr[mid])
            r = mid - 1;
       
        // move the left pointer
        else
            l = mid + 1;
    }
   
    return mid;
}
 
// Driver Code
int main()
{
    int arr[] = { 1, 3, 20, 4, 1, 0 };
    int N = sizeof(arr) / sizeof(arr[0]);
    cout << ""Index of a peak point is "" << findPeak(arr, N);
    return 0;
}
 
// This code is contributed by Rajdeep Mallick (rajdeep999)",logn,n,linear,0,n
23,"#include <bits/stdc++.h>
using namespace std;
 
/**
 * Reverse Row at specified index in the matrix
 * @param data matrix
 * @param index row index
 */
void reverseRow(vector<vector<int>>& data,
                int index)
{
    int cols = data[index].size();
    for(int i = 0; i < cols / 2; i++)
    {
        int temp = data[index][i];
        data[index][i] = data[index][cols - i - 1];
        data[index][cols - i - 1] = temp;
    }
}
 
/**
 * Print Matrix data
 * @param data matrix
 */
void printMatrix(vector<vector<int>>& data)
{
    for(int i = 0; i < data.size(); i++)
    {
        for(int j = 0; j < data[i].size(); j++)
        {
            cout << data[i][j] << "" "";
        }
        cout << endl;
    }
}
 
/**
 * Rotate Matrix by 180 degrees
 * @param data matrix
 */
void rotateMatrix180(vector<vector<int>>& data)
{
    int rows = data.size();
    int cols = data[0].size();
 
    if (rows % 2 != 0)
    {
         
        // If N is odd reverse the middle
        // row in the matrix
        reverseRow(data, data.size() / 2);
    }
     
    // Swap the value of matrix [i][j] with
    // [rows - i - 1][cols - j - 1] for half    
    // the rows size.
    for(int i = 0; i <= (rows/2) - 1; i++)
    {
        for(int j = 0; j < cols; j++)
        {
            int temp = data[i][j];
            data[i][j] = data[rows - i - 1][cols - j - 1];
            data[rows - i - 1][cols - j - 1] = temp;
        }
    }
}
 
// Driver code   
int main()
{
    vector<vector<int>> data{ { 1, 2, 3, 4, 5 },
                              { 6, 7, 8, 9, 10 },
                              { 11, 12, 13, 14, 15 },
                              { 16, 17, 18, 19, 20 },
                              { 21, 22, 23, 24, 25 } };
 
    // Rotate Matrix
    rotateMatrix180(data);
 
    // Print Matrix
    printMatrix(data);
 
    return 0;
}
 
// This code is contributed by divyeshrabadiya07",quadratic,quadratic,quadratic,1,quadratic
24,"#include <bits/stdc++.h>
using namespace std;
 
// Structure of a BST Node
class Node {
public:
    int val;
    Node* left;
    Node* right;
};
 
/* Utility function to create a new Binary Tree Node */
Node* newNode(int data)
{
    Node* temp = new Node;
    temp->val = data;
    temp->left = nullptr;
    temp->right = nullptr;
    return temp;
}
 
vector<int> mergeTwoBST(Node* root1, Node* root2)
{
    vector<int> res;
    stack<Node*> s1, s2;
    while (root1 || root2 || !s1.empty() || !s2.empty()) {
        while (root1) {
            s1.push(root1);
            root1 = root1->left;
        }
        while (root2) {
            s2.push(root2);
            root2 = root2->left;
        }
        // Step 3 Case 1:-
        if (s2.empty()
            || (!s1.empty()
                && s1.top()->val <= s2.top()->val)) {
            root1 = s1.top();
            s1.pop();
            res.push_back(root1->val);
            root1 = root1->right;
        }
        // Step 3 case 2 :-
        else {
            root2 = s2.top();
            s2.pop();
            res.push_back(root2->val);
            root2 = root2->right;
        }
    }
    return res;
}
 
/* Driver program to test above functions */
int main()
{
    Node *root1 = nullptr, *root2 = nullptr;
 
    /* Let us create the following tree as first tree
       3
      / \
      1 5
    */
    root1 = newNode(3);
    root1->left = newNode(1);
    root1->right = newNode(5);
 
    /* Let us create the following tree as second tree
       4
      / \
      2 6
    */
    root2 = newNode(4);
    root2->left = newNode(2);
    root2->right = newNode(6);
 
    // Print sorted Nodes of both trees
    vector<int> ans = mergeTwoBST(root1, root2);
    for (auto it : ans)
        cout << it << "" "";
    return 0;
}
 
// This code is contributed by Aditya kumar (adityakumar129)",linear,nlogn,nlogn,0,nlogn
25,"// A recursive CPP program to find
// LCA of two nodes n1 and n2.
#include <bits/stdc++.h>
using namespace std;
 
class node {
public:
    int data;
    node *left, *right;
};
 
/* Function to find LCA of n1 and n2.
The function assumes that both
n1 and n2 are present in BST */
node* lca(node* root, int n1, int n2)
{
    if (root == NULL)
        return NULL;
 
    // If both n1 and n2 are smaller
    // than root, then LCA lies in left
    if (root->data > n1 && root->data > n2)
        return lca(root->left, n1, n2);
 
    // If both n1 and n2 are greater than
    // root, then LCA lies in right
    if (root->data < n1 && root->data < n2)
        return lca(root->right, n1, n2);
 
    return root;
}
 
/* Helper function that allocates
a new node with the given data.*/
node* newNode(int data)
{
    node* Node = new node();
    Node->data = data;
    Node->left = Node->right = NULL;
    return (Node);
}
 
/* Driver code*/
int main()
{
    // Let us construct the BST
    // shown in the above figure
    node* root = newNode(20);
    root->left = newNode(8);
    root->right = newNode(22);
    root->left->left = newNode(4);
    root->left->right = newNode(12);
    root->left->right->left = newNode(10);
    root->left->right->right = newNode(14);
 
      // Function calls
    int n1 = 10, n2 = 14;
    node* t = lca(root, n1, n2);
    cout << ""LCA of "" << n1 << "" and "" << n2 << "" is ""
         << t->data << endl;
 
    n1 = 14, n2 = 8;
    t = lca(root, n1, n2);
    cout << ""LCA of "" << n1 << "" and "" << n2 << "" is ""
         << t->data << endl;
 
    n1 = 10, n2 = 22;
    t = lca(root, n1, n2);
    cout << ""LCA of "" << n1 << "" and "" << n2 << "" is ""
         << t->data << endl;
    return 0;
}
 
// This code is contributed by rathbhupendra",constant,nlogn,nlogn,0,nlogn
26,"// C++ program to count BST nodes within a given range
#include<bits/stdc++.h>
using namespace std;
 
// A BST node
struct node
{
    int data;
    struct node* left, *right;
};
 
// Utility function to create new node
node *newNode(int data)
{
    node *temp = new node;
    temp->data  = data;
    temp->left  = temp->right = NULL;
    return (temp);
}
 
// Returns count of nodes in BST in range [low, high]
int getCount(node *root, int low, int high)
{
    // Base case
    if (!root) return 0;
 
    // Special Optional case for improving efficiency
    if (root->data == high && root->data == low)
        return 1;
 
    // If current node is in range, then include it in count and
    // recur for left and right children of it
    if (root->data <= high && root->data >= low)
         return 1 + getCount(root->left, low, high) +
                    getCount(root->right, low, high);
 
    // If current node is smaller than low, then recur for right
    // child
    else if (root->data < low)
         return getCount(root->right, low, high);
 
    // Else recur for left child
    else return getCount(root->left, low, high);
}
 
// Driver program
int main()
{
    // Let us construct the BST shown in the above figure
    node *root        = newNode(10);
    root->left        = newNode(5);
    root->right       = newNode(50);
    root->left->left  = newNode(1);
    root->right->left = newNode(40);
    root->right->right = newNode(100);
    /* Let us constructed BST shown in above example
          10
        /    \
      5       50
     /       /  \
    1       40   100   */
    int l = 5;
    int h = 45;
    cout << ""Count of nodes between ["" << l << "", "" << h
         << ""] is "" << getCount(root, l, h);
    return 0;
}",constant,nlogn,nlogn,0,nlogn
27,"// C++ Program to find ceil of a given value in BST
#include <bits/stdc++.h>
using namespace std;
 
/* A binary tree node has key, left child and right child */
class node {
public:
    int key;
    node* left;
    node* right;
};
 
/* Helper function that allocates a new node with the given
key and NULL left and right pointers.*/
node* newNode(int key)
{
    node* Node = new node();
    Node->key = key;
    Node->left = NULL;
    Node->right = NULL;
    return (Node);
}
 
// Function to find ceil of a given input in BST. If input
// is more than the max key in BST, return -1
int Ceil(node* root, int input)
{
    // Base case
    if (root == NULL)
        return -1;
 
    // We found equal key
    if (root->key == input)
        return root->key;
 
    // If root's key is smaller, ceil must be in right
    // subtree
    if (root->key < input)
        return Ceil(root->right, input);
 
    // Else, either left subtree or root has the ceil value
    int ceil = Ceil(root->left, input);
    return (ceil >= input) ? ceil : root->key;
}
 
// Driver code
int main()
{
    node* root = newNode(8);
 
    root->left = newNode(4);
    root->right = newNode(12);
 
    root->left->left = newNode(2);
    root->left->right = newNode(6);
 
    root->right->left = newNode(10);
    root->right->right = newNode(14);
 
    for (int i = 0; i < 16; i++)
        cout << i << "" "" << Ceil(root, i) << endl;
 
    return 0;
}
 
// This code is contributed by rathbhupendra",logn,nlogn,nlogn,0,nlogn
28,"// C++ Program to find floor of a given value in BST
#include <bits/stdc++.h>
using namespace std;
 
/* A binary tree node has key, left child and right child */
class node {
public:
    int key;
    node* left;
    node* right;
};
 
/* Helper function that allocates a new node with the given
key and NULL left and right pointers.*/
node* newNode(int key)
{
    node* Node = new node();
    Node->key = key;
    Node->left = NULL;
    Node->right = NULL;
    return (Node);
}
 
// Function to find floor of a given input in BST. If input
// is more than the min key in BST, return -1
int Floor(node* root, int input)
{
    // Base case
    if (root == NULL)
        return -1;
 
    // We found equal key
    if (root->key == input)
        return root->key;
 
    // If root's key is larger, floor must be in left
    // subtree
    if (root->key > input)
        return Floor(root->left, input);
 
    // Else, either right subtree or root has the floor
    // value
    else {
        int floor = Floor(root->right, input);
        // exception for -1 because it is being returned in
        // base case
        return (floor <= input && floor != -1) ? floor
                                               : root->key;
    }
}
 
// Driver code
int main()
{
    node* root = newNode(8);
 
    root->left = newNode(4);
    root->right = newNode(12);
 
    root->left->left = newNode(2);
    root->left->right = newNode(6);
 
    root->right->left = newNode(10);
    root->right->right = newNode(14);
 
    for (int i = 0; i < 16; i++)
        cout << i << "" "" << Floor(root, i) << endl;
 
    return 0;
}
 
// This code is contributed by rathbhupendra",logn,nlogn,nlogn,0,nlogn
29,"// C++ program to find floor and ceil of a given key in BST
#include <bits/stdc++.h>
using namespace std;
 
/* A binary tree node has key, left child and right child */
struct Node {
    int data;
    Node *left, *right;
 
    Node(int value)
    {
        data = value;
        left = right = NULL;
    }
};
 
// Helper function to find floor and ceil of a given key in
// BST
void floorCeilBSTHelper(Node* root, int key, int& floor,
                        int& ceil)
{
 
    while (root) {
 
        if (root->data == key) {
            ceil = root->data;
            floor = root->data;
            return;
        }
 
        if (key > root->data) {
            floor = root->data;
            root = root->right;
        }
        else {
            ceil = root->data;
            root = root->left;
        }
    }
    return;
}
 
// Display the floor and ceil of a given key in BST.
// If key is less than the min key in BST, floor will be -1;
// If key is more than the max key in BST, ceil will be -1;
void floorCeilBST(Node* root, int key)
{
 
    // Variables 'floor' and 'ceil' are passed by reference
    int floor = -1, ceil = -1;
 
    floorCeilBSTHelper(root, key, floor, ceil);
 
    cout << key << ' ' << floor << ' ' << ceil << '\n';
}
 
// Driver code
int main()
{
    Node* root = new Node(8);
 
    root->left = new Node(4);
    root->right = new Node(12);
 
    root->left->left = new Node(2);
    root->left->right = new Node(6);
 
    root->right->left = new Node(10);
    root->right->right = new Node(14);
 
    for (int i = 0; i < 16; i++)
        floorCeilBST(root, i);
 
    return 0;
}",logn,nlogn,nlogn,0,nlogn
30,"// C++ implementation of tree using array
// numbering starting from 0 to n-1.
#include<bits/stdc++.h>
using namespace std;
char tree[10];
int root(char key) {
  if (tree[0] != '\0')
    cout << ""Tree already had root"";
  else
    tree[0] = key;
  return 0;
}
 
int set_left(char key, int parent) {
  if (tree[parent] == '\0')
    cout << ""\nCan't set child at ""
    << (parent * 2) + 1
    << "" , no parent found"";
  else
    tree[(parent * 2) + 1] = key;
  return 0;
}
 
int set_right(char key, int parent) {
  if (tree[parent] == '\0')
    cout << ""\nCan't set child at ""
    << (parent * 2) + 2
    << "" , no parent found"";
  else
    tree[(parent * 2) + 2] = key;
  return 0;
}
 
int print_tree() {
  cout << ""\n"";
  for (int i = 0; i < 10; i++) {
    if (tree[i] != '\0')
      cout << tree[i];
    else
      cout << ""-"";
  }
  return 0;
}
 
// Driver Code
int main() {
  root('A');
  set_left('B',0);
  set_right('C', 0);
  set_left('D', 1);
  set_right('E', 1);
  set_right('F', 2);
  print_tree();
  return 0;
}",logn,quadratic,quadratic,0,quadratic
31,"// Given an ancestor matrix for binary tree, construct
// the tree.
#include <bits/stdc++.h>
using namespace std;
   
# define N 6
   
/* A binary tree node */
struct Node
{
    int data;
    Node *left, *right;
};
   
/* Helper function to create a new node */
Node* newNode(int data)
{
    Node* node = new Node;
    node->data = data;
    node->left = node->right = NULL;
    return (node);
}
   
// Constructs tree from ancestor matrix
Node* ancestorTree(int mat[][N])
{
    // Binary array to determine whether
    // parent is set for node i or not
    int parent[N] = {0};
   
    // Root will store the root of the constructed tree
    Node* root = NULL;
   
    // Create a multimap, sum is used as key and row
    // numbers are used as values
    multimap<int, int> mm;
   
    for (int i = 0; i < N; i++)
    {
        int sum = 0; // Initialize sum of this row
        for (int j = 0; j < N; j++)
            sum += mat[i][j];
   
        // insert(sum, i) pairs into the multimap
        mm.insert(pair<int, int>(sum, i));
    }
   
    // node[i] will store node for i in constructed tree
    Node* node[N];
   
    // Traverse all entries of multimap.  Note that values
    // are accessed in increasing order of sum
    for (auto it = mm.begin(); it != mm.end(); ++it)
    {
      // create a new node for every value
      node[it->second] = newNode(it->second);
   
      // To store last processed node. This node will be
      // root after loop terminates
      root = node[it->second];
   
      // if non-leaf node
      if (it->first != 0)
      {
        // traverse row 'it->second' in the matrix
        for (int i = 0; i < N; i++)
        {
           // if parent is not set and ancestor exits
           if (!parent[i] && mat[it->second][i])
           {
             // check for unoccupied left/right node
             // and set parent of node i
             if (!node[it->second]->left)
               node[it->second]->left = node[i];
             else
               node[it->second]->right = node[i];
   
             parent[i] = 1;
           }
        }
      }
    }
    return root;
}
   
/* Given a binary tree, print its nodes in inorder */
void printInorder(Node* node)
{
    if (node == NULL)
        return;
    printInorder(node->left);
    printf(""%d "", node->data);
    printInorder(node->right);
}
   
// Driver code
int main()
{
    int mat[N][N] = {{ 0, 0, 0, 0, 0, 0 },
        { 1, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 1, 0, 0 },
        { 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0 },
        { 1, 1, 1, 1, 1, 0 }
    };
   
    Node* root = ancestorTree(mat);
   
    cout << ""Inorder traversal of tree is \n"";
     
    // Function call
    printInorder(root);
   
    return 0;
}",quadratic,nlogn,nlogn,0,nlogn
32,"/* Program to check children sum property */
#include <bits/stdc++.h>
using namespace std;
 
/* A binary tree node has data, left
child and right child */
struct node {
    int data;
    struct node* left;
    struct node* right;
};
 
/* returns 1 if children sum property holds
for the given node and both of its children*/
int isSumProperty(struct node* node)
{
    /* left_data is left child data and
       right_data is for right child data*/
    int sum = 0;
 
    /* If node is NULL or it's a leaf node
    then return true */
    if (node == NULL
        || (node->left == NULL && node->right == NULL))
        return 1;
    else {
        /* If left child is not present then 0
        is used as data of left child */
        if (node->left != NULL)
            sum += node->left->data;
 
        /* If right child is not present then 0
        is used as data of right child */
        if (node->right != NULL)
            sum += node->right->data;
 
        /* if the node and both of its children
        satisfy the property return 1 else 0*/
        return ((node->data == sum)
                && isSumProperty(node->left)
                && isSumProperty(node->right));
    }
}
 
/*
Helper function that allocates a new node
with the given data and NULL left and right
pointers.
*/
struct node* newNode(int data)
{
    struct node* node
        = (struct node*)malloc(sizeof(struct node));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    return (node);
}
 
// Driver Code
int main()
{
    struct node* root = newNode(10);
    root->left = newNode(8);
    root->right = newNode(2);
    root->left->left = newNode(3);
    root->left->right = newNode(5);
    root->right->right = newNode(2);
 
    // Function call
    if (isSumProperty(root))
        cout << ""The given tree satisfies ""
             << ""the children sum property "";
    else
        cout << ""The given tree does not satisfy ""
             << ""the children sum property "";
 
    getchar();
    return 0;
}
// This code is contributed by Akanksha Rai",linear,n,linear,1,n
33,"// C++ program to print all root to leaf paths
// with there relative position
#include<bits/stdc++.h>
using namespace std;
 
#define MAX_PATH_SIZE 1000
 
// tree structure
struct Node
{
    char data;
    Node *left, *right;
};
 
// function create new node
Node * newNode(char data)
{
    struct Node *temp = new Node;
    temp->data = data;
    temp->left = temp->right = NULL;
    return temp;
}
 
// store path information
struct PATH
{
    int  Hd; // horizontal distance of node from root.
    char key; // store key
};
 
// Prints given root to leaf path with underscores
void printPath(vector < PATH > path, int size)
{
    // Find the minimum horizontal distance value
    // in current root to leaf path
    int minimum_Hd = INT_MAX;
 
    PATH p;
 
    // find minimum horizontal distance
    for (int it=0; it<size; it++)
    {
        p = path[it];
        minimum_Hd = min(minimum_Hd, p.Hd);
    }
 
    // print the root to leaf path with ""_""
    // that indicate the related position
    for (int it=0; it < size; it++)
    {
        // current tree node
        p = path[it];
        int noOfUnderScores = abs(p.Hd - minimum_Hd);
 
        // print underscore
        for (int i = 0; i < noOfUnderScores; i++)
            cout << ""_ "";
 
        // print current key
        cout << p.key << endl;
    }
    cout << ""=============================="" << endl;
}
 
// a utility function print all path from root to leaf
// working of this function is similar to function of
// ""Print_vertical_order"" : Print paths of binary tree
// in vertical order
// https://www.geeksforgeeks.org/print-binary-tree-vertical-order-set-2/
void printAllPathsUtil(Node *root,
                       vector < PATH > &AllPath,
                       int HD, int order )
{
    // base case
    if(root == NULL)
        return;
 
    // leaf node
    if (root->left == NULL && root->right == NULL)
    {
        // add leaf node and then print path
        AllPath[order] = (PATH { HD, root->data });
        printPath(AllPath, order+1);
        return;
    }
 
    // store current path information
    AllPath[order] = (PATH { HD, root->data });
 
    // call left sub_tree
    printAllPathsUtil(root->left, AllPath, HD-1, order+1);
 
    //call left sub_tree
    printAllPathsUtil(root->right, AllPath, HD+1, order+1);
}
 
void printAllPaths(Node *root)
{
    // base case
    if (root == NULL)
        return;
 
    vector<PATH> Allpaths(MAX_PATH_SIZE);
    printAllPathsUtil(root, Allpaths, 0, 0);
}
 
// Driver program to test above function
int main()
{
    Node *root = newNode('A');
    root->left = newNode('B');
    root->right = newNode('C');
    root->left->left = newNode('D');
    root->left->right = newNode('E');
    root->right->left = newNode('F');
    root->right->right = newNode('G');
    printAllPaths(root);
    return 0;
}",constant,nlogn,nlogn,0,nlogn
34,"// CPP program to find largest three elements in
// a binary tree.
#include <bits/stdc++.h>
using namespace std;
 
struct Node {
  int data;
  struct Node *left;
  struct Node *right;
};
 
/* Helper function that allocates a new Node with the
   given data and NULL left and right pointers. */
struct Node *newNode(int data) {
  struct Node *node = new Node;
  node->data = data;
  node->left = NULL;
  node->right = NULL;
  return (node);
}
 
// function to find three largest element
void threelargest(Node *root, int &first, int &second,
                                          int &third) {
  if (root == NULL)
    return;
 
  // if data is greater than first large number
  // update the top three list
  if (root->data > first) {
    third = second;
    second = first;
    first = root->data;
  }
 
  // if data is greater than second large number
  // and not equal to first update the bottom
  // two list
  else if (root->data > second && root->data != first) {
    third = second;
    second = root->data;
  }
 
  // if data is greater than third large number
  // and not equal to first & second update the
  // third highest list
  else if (root->data > third &&
           root->data != first &&
           root->data != second)
    third = root->data;
 
  threelargest(root->left, first, second, third);
  threelargest(root->right, first, second, third);
}
 
// driver function
int main() {
  struct Node *root = newNode(1);
  root->left = newNode(2);
  root->right = newNode(3);
  root->left->left = newNode(4);
  root->left->right = newNode(5);
  root->right->left = newNode(4);
  root->right->right = newNode(5);
 
  int first = 0, second = 0, third = 0;
  threelargest(root, first, second, third);
  cout << ""three largest elements are ""
       << first << "" "" << second << "" ""
       << third;
  return 0;
}",linear,nlogn,nlogn,0,nlogn
35,"/* C++ program to solve N Queen Problem using
   backtracking */
  
#include <bits/stdc++.h>
#define N 4
using namespace std;
  
/* A utility function to print solution */
void printSolution(int board[N][N])
{
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++)
            cout << "" "" << board[i][j] << "" "";
        printf(""\n"");
    }
}
  
/* A utility function to check if a queen can
   be placed on board[row][col]. Note that this
   function is called when ""col"" queens are
   already placed in columns from 0 to col -1.
   So we need to check only left side for
   attacking queens */
bool isSafe(int board[N][N], int row, int col)
{
    int i, j;
  
    /* Check this row on left side */
    for (i = 0; i < col; i++)
        if (board[row][i])
            return false;
  
    /* Check upper diagonal on left side */
    for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
        if (board[i][j])
            return false;
  
    /* Check lower diagonal on left side */
    for (i = row, j = col; j >= 0 && i < N; i++, j--)
        if (board[i][j])
            return false;
  
    return true;
}
  
/* A recursive utility function to solve N
   Queen problem */
bool solveNQUtil(int board[N][N], int col)
{
    /* base case: If all queens are placed
      then return true */
    if (col >= N)
        return true;
  
    /* Consider this column and try placing
       this queen in all rows one by one */
    for (int i = 0; i < N; i++) {
        /* Check if the queen can be placed on
          board[i][col] */
        if (isSafe(board, i, col)) {
            /* Place this queen in board[i][col] */
            board[i][col] = 1;
  
            /* recur to place rest of the queens */
            if (solveNQUtil(board, col + 1))
                return true;
  
            /* If placing queen in board[i][col]
               doesn't lead to a solution, then
               remove queen from board[i][col] */
            board[i][col] = 0; // BACKTRACK
        }
    }
  
    /* If the queen cannot be placed in any row in
        this column col  then return false */
    return false;
}
  
/* This function solves the N Queen problem using
   Backtracking. It mainly uses solveNQUtil() to
   solve the problem. It returns false if queens
   cannot be placed, otherwise, return true and
   prints placement of queens in the form of 1s.
   Please note that there may be more than one
   solutions, this function prints one  of the
   feasible solutions.*/
bool solveNQ()
{
    int board[N][N] = { { 0, 0, 0, 0 },
                        { 0, 0, 0, 0 },
                        { 0, 0, 0, 0 },
                        { 0, 0, 0, 0 } };
  
    if (solveNQUtil(board, 0) == false) {
        cout << ""Solution does not exist"";
        return false;
    }
  
    printSolution(board);
    return true;
}
  
// driver program to test above function
int main()
{
    solveNQ();
    return 0;
}
  
// This code is contributed by Aditya Kumar (adityakumar129)",np,nlogn,nlogn,0,nlogn
36,"// Dynamic Programming based C++ program to find shortest path with
// exactly k edges
#include <iostream>
#include <climits>
using namespace std;
 
// Define number of vertices in the graph and infinite value
#define V 4
#define INF INT_MAX
 
// A Dynamic programming based function to find the shortest path from
// u to v with exactly k edges.
int shortestPath(int graph[][V], int u, int v, int k)
{
    // Table to be filled up using DP. The value sp[i][j][e] will store
    // weight of the shortest path from i to j with exactly k edges
    int sp[V][V][k+1];
 
    // Loop for number of edges from 0 to k
    for (int e = 0; e <= k; e++)
    {
        for (int i = 0; i < V; i++)  // for source
        {
            for (int j = 0; j < V; j++) // for destination
            {
                // initialize value
                sp[i][j][e] = INF;
 
                // from base cases
                if (e == 0 && i == j)
                    sp[i][j][e] = 0;
                if (e == 1 && graph[i][j] != INF)
                    sp[i][j][e] = graph[i][j];
 
                //go to adjacent only when number of edges is more than 1
                if (e > 1)
                {
                    for (int a = 0; a < V; a++)
                    {
                        // There should be an edge from i to a and a
                        // should not be same as either i or j
                        if (graph[i][a] != INF && i != a &&
                            j!= a && sp[a][j][e-1] != INF)
                          sp[i][j][e] = min(sp[i][j][e], graph[i][a] +
                                                       sp[a][j][e-1]);
                    }
                }
           }
        }
    }
    return sp[u][v][k];
}
 
// driver program to test above function
int main()
{
    /* Let us create the graph shown in above diagram*/
     int graph[V][V] = { {0, 10, 3, 2},
                        {INF, 0, INF, 7},
                        {INF, INF, 0, 6},
                        {INF, INF, INF, 0}
                      };
    int u = 0, v = 3, k = 2;
    cout << shortestPath(graph, u, v, k);
    return 0;
}",cubic,nlogn,nlogn,0,nlogn
37,"// C++ program to find length
// of the shortest chain
// transformation from source
// to target
#include <bits/stdc++.h>
using namespace std;
 
// Returns length of shortest chain
// to reach 'target' from 'start'
// using minimum number of adjacent
// moves.  D is dictionary
int shortestChainLen(
string start, string target,
set<string>& D)
{
   
   if(start == target)
      return 0;
   
  // Map of intermediate words and
  // the list of original words
  map<string, vector<string>> umap;
 
  // Find all the intermediate
  // words for the start word
  for(int i = 0; i < start.size(); i++)
  {
    string str = start.substr(0,i) + ""*"" +
                        start.substr(i+1);
    umap[str].push_back(start);
  }
 
  // Find all the intermediate words for
  // the words in the given Set
  for(auto it = D.begin(); it != D.end(); it++)
  {
    string word = *it;
    for(int j = 0; j < word.size(); j++)
    {
      string str = word.substr(0,j) + ""*"" +
                          word.substr(j+1);
      umap[str].push_back(word);
    }
  }
 
  // Perform BFS and push (word, distance)
  queue<pair<string, int>> q;
 
  map<string, int> visited;
 
  q.push(make_pair(start,1));
  visited[start] = 1;
 
  // Traverse until queue is empty
  while(!q.empty())
  {
    pair<string, int> p = q.front();
    q.pop();
 
    string word = p.first;
    int dist = p.second;
 
    // If target word is found
    if(word == target)
    {
      return dist;
    }
 
    // Finding intermediate words for
    // the word in front of queue
    for(int i = 0; i < word.size(); i++)
    {
      string str = word.substr(0,i) + ""*"" +
                           word.substr(i+1);
 
      vector<string> vect = umap[str];
      for(int j = 0; j < vect.size(); j++)
      {
        // If the word is not visited
        if(visited[vect[j]] == 0)
        {
          visited[vect[j]] = 1;
          q.push(make_pair(vect[j], dist + 1));
        }
      }
    }
 
  }
 
    return 0;
}
 
// Driver code
int main()
{
    // Make dictionary
    set<string> D;
    D.insert(""poon"");
    D.insert(""plee"");
    D.insert(""same"");
    D.insert(""poie"");
    D.insert(""plie"");
    D.insert(""poin"");
    D.insert(""plea"");
    string start = ""toon"";
    string target = ""plea"";
    cout << ""Length of shortest chain is: ""
         << shortestChainLen(start, target, D);
    return 0;
}",cubic,n,linear,0,n
38,"// CPP14 program to find common contacts.
#include <bits/stdc++.h>
using namespace std;
 
// The class DSU will implement the Union Find
class DSU {
 
    vector<int> parent, size;
 
public:
    // In the constructor, we assign the each index as its
    // own parent and size as the number of contacts
    // available for that index
 
    DSU(vector<vector<string> >& contacts)
    {
        for (int i = 0; i < contacts.size(); i++) {
 
            parent.push_back(i);
 
            size.push_back(contacts[i].size());
        }
    }
 
    // Finds the set in which the element belongs. Path
    // compression is used to optimise time complexity
    int findSet(int v)
    {
 
        if (v == parent[v])
            return v;
 
        return parent[v] = findSet(parent[v]);
    }
 
    // Unifies the sets a and b where, the element belonging
    // to the smaller set is merged to the one belonging to
    // the smaller set
    void unionSet(int a, int b, vector<string>& person1,
                  vector<string>& person2)
    {
 
        if (size[a] > size[b]) {
            parent[b] = a;
            size[a] += size[b];
            for (auto contact : person2)
                person1.push_back(contact);
        }
        else {
 
            parent[a] = b;
            size[b] += size[a];
            for (auto contact : person1)
                person2.push_back(contact);
        }
    }
};
 
// Driver Code
int main()
{
    vector<vector<string> > contacts = {
        { ""Gaurav"", ""gaurav@gmail.com"",
          ""gaurav@gfgQA.com"" },
        { ""Lucky"", ""lucky@gmail.com"", ""+1234567"" },
        { ""gaurav123"", ""+5412312"", ""gaurav123@skype.com"" },
        { ""gaurav1993"", ""+5412312"", ""gaurav@gfgQA.com"" },
        { ""raja"", ""+2231210"", ""raja@gfg.com"" },
        { ""bahubali"", ""+878312"", ""raja"" }
    };
 
    // Initializing the object of DSU class
    DSU dsu(contacts);
 
    // Will contain the mapping of a contact to all the
    // indices it is present within
    unordered_map<string, vector<int> > contactToIndex;
 
    for (int index = 0; index < contacts.size(); index++) {
 
        for (auto contact : contacts[index])
            contactToIndex[contact].push_back(index);
    }
 
    // Unifies the sets of each contact if they are not
    // present in the same set
    for (auto contact : contactToIndex) {
 
        vector<int> indices = contact.second;
 
        for (int i = 0; i < indices.size() - 1; i++) {
 
            int set1 = dsu.findSet(indices[i]),
                set2 = dsu.findSet(indices[i + 1]);
 
            if (set1 != set2)
                dsu.unionSet(set1, set2, contacts[set1],
                             contacts[set2]);
        }
    }
 
    // Contains a map of all the distinct sets available
    // after union find has been completed
    unordered_map<int, vector<int> > unifiedSet;
 
    // All parents are mapped to the elements in the set
    for (int i = 0; i < contacts.size(); i++) {
 
        unifiedSet[dsu.findSet(i)].push_back(i);
    }
 
    // Printing out elements from distinct sets
    for (auto eachSet : unifiedSet) {
 
        for (auto element : eachSet.second)
            cout << element << "" "";
 
        cout << endl;
    }
 
    return 0;
}",np,nlogn,nlogn,0,nlogn
39,"// C++ program to check if given array
// has 2 elements whose sum is equal
// to the given value
 
#include <bits/stdc++.h>
using namespace std;
 
bool binarySearch(int A[], int low, int high, int searchKey)
{
 
    while (low <= high) {
        int m = low + (high - low) / 2;
 
        // Check if searchKey is present at mid
        if (A[m] == searchKey)
            return true;
 
        // If searchKey greater, ignore left half
        if (A[m] < searchKey)
            low = m + 1;
 
        // If searchKey is smaller, ignore right half
        else
            high = m - 1;
    }
 
    // if we reach here, then element was
    // not present
    return false;
}
 
bool checkTwoSum(int A[], int arr_size, int sum)
{
    int l, r;
 
    /* Sort the elements */
    sort(A, A + arr_size);
 
    // Traversing all element in an array search for
    // searchKey
    for (int i = 0; i < arr_size - 1; i++) {
 
        int searchKey = sum - A[i];
        // calling binarySearch function
        if (binarySearch(A, i + 1, arr_size - 1, searchKey)
            == true) {
            return true;
        }
    }
    return false;
}
 
/* Driver program to test above function */
int main()
{
    int A[] = { 1, 4, 45, 6, 10, -8 };
    int n = 14;
    int arr_size = sizeof(A) / sizeof(A[0]);
 
    // Function calling
    if (checkTwoSum(A, arr_size, n))
        cout << ""Yes"";
    else
        cout << ""No"";
 
    return 0;
}",nlogn,nlogn,nlogn,1,nlogn
40,"// C++ program to find top k elements in a stream
#include <bits/stdc++.h>
using namespace std;
 
// Function to print top k numbers
void kTop(int a[], int n, int k)
{
    // vector of size k+1 to store elements
    vector<int> top(k + 1);
 
    // array to keep track of frequency
    unordered_map<int, int> freq;
 
    // iterate till the end of stream
    for (int m = 0; m < n; m++) {
        // increase the frequency
        freq[a[m]]++;
 
        // store that element in top vector
        top[k] = a[m];
 
        // search in top vector for same element
        auto it = find(top.begin(), top.end() - 1, a[m]);
 
        // iterate from the position of element to zero
        for (int i = distance(top.begin(), it) - 1; i >= 0; --i) {
            // compare the frequency and swap if higher
            // frequency element is stored next to it
            if (freq[top[i]] < freq[top[i + 1]])
                swap(top[i], top[i + 1]);
 
            // if frequency is same compare the elements
            // and swap if next element is high
            else if ((freq[top[i]] == freq[top[i + 1]])
                     && (top[i] > top[i + 1]))
                swap(top[i], top[i + 1]);
            else
                break;
        }
 
        // print top k elements
        for (int i = 0; i < k && top[i] != 0; ++i)
            cout << top[i] << ' ';
    }
    cout << endl;
}
 
// Driver program to test above function
int main()
{
    int k = 4;
    int arr[] = { 5, 2, 1, 3, 2 };
    int n = sizeof(arr) / sizeof(arr[0]);
    kTop(arr, n, k);
    return 0;
}",quadratic,quadratic,quadratic,1,quadratic
41,"// CPP program to find the only repeating
// element in an array where elements are
// from 1 to N-1.
#include <bits/stdc++.h>
using namespace std;
 
int findRepeating(int arr[], int N)
{
    sort(arr, arr + N); // sort array
 
    for (int i = 0; i < N; i++) {
 
        // compare array element with its index
        if (arr[i] != i + 1) {
            return arr[i];
        }
    }
    return -1;
}
 
// driver's code
int main()
{
    int arr[] = { 9, 8, 2, 6, 1, 8, 5, 3, 4, 7 };
    int N = sizeof(arr) / sizeof(arr[0]);
 
    // Function call
    cout << findRepeating(arr, N);
    return 0;
}
// this code is contributed by devendra solunke",nlogn,quadratic,quadratic,0,quadratic
42,"#include<bits/stdc++.h>
using namespace std;
 
// C++ program to group multiple
// occurrences of individual array elements
 
// A hashing based method to group
// all occurrences of individual elements
void orderedGroup(vector<int>&arr){
     
    // Creates an empty hashmap
    map<int,int>hM;
 
    // Traverse the array elements, and store
    // count for every element in HashMap
    for(int i=0;i<arr.size();i++){
         
        // Increment count of elements
        // in HashMap
        hM[arr[i]]++;
    }
         
    // Traverse array again
    for(int i=0;i<arr.size();i++){
         
        // Check if this is first occurrence
        int count = (hM.find(arr[i]) == hM.end())? 0 : hM[arr[i]];   
        if(hM.find(arr[i]) != hM.end()){
             
            // If yes, then print
            // the element 'count' times
            for(int j=0;j<count;j++){
                cout<<arr[i]<<"" "";
            }
                 
            // And remove the element from HashMap.
            hM.erase(arr[i]);
        }
    }
}
     
// Driver Code
int main(){
  
vector<int>arr = {10, 5, 3, 10, 10, 4, 1, 3};
orderedGroup(arr);
   
}
 
// This code is contributed by shinjanpatra",linear,n,linear,1,n
43,"// C++ simple program to
// find elements which are
// not present in second array
#include<bits/stdc++.h>
using namespace std;
 
// Function for finding
// elements which are there
// in a[]  but not in b[].
void findMissing(int a[], int b[],
                 int n, int m)
{
    for (int i = 0; i < n; i++)
    {
        int j;
        for (j = 0; j < m; j++)
            if (a[i] == b[j])
                break;
 
        if (j == m)
            cout << a[i] << "" "";
    }
}
 
// Driver code
int main()
{
    int a[] = { 1, 2, 6, 3, 4, 5 };
    int b[] = { 2, 4, 3, 1, 0 };
    int n = sizeof(a) / sizeof(a[0]);
    int m = sizeof(b) / sizeof(b[1]);
    findMissing(a, b, n, m);
    return 0;
}",quadratic,quadratic,quadratic,1,quadratic
44,"   
// C++ implementation to count quadruples from four sorted arrays
// whose sum is equal to a given value x
#include <bits/stdc++.h>
 
using namespace std;
 
// function to count all quadruples from
// four sorted arrays whose sum is equal
// to a given value x
int countQuadruples(int arr1[], int arr2[],
                    int arr3[], int arr4[], int n, int x)
{
    int count = 0;
 
    // generate all possible quadruples from
    // the four sorted arrays
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            for (int k = 0; k < n; k++)
                for (int l = 0; l < n; l++)
                    // check whether elements of
                    // quadruple sum up to x or not
                    if ((arr1[i] + arr2[j] + arr3[k] + arr4[l]) == x)
                        count++;
 
    // required count of quadruples
    return count;
}
 
// Driver program to test above
int main()
{
    // four sorted arrays each of size 'n'
    int arr1[] = { 1, 4, 5, 6 };
    int arr2[] = { 2, 3, 7, 8 };
    int arr3[] = { 1, 4, 6, 10 };
    int arr4[] = { 2, 4, 7, 8 };
 
    int n = sizeof(arr1) / sizeof(arr1[0]);
    int x = 30;
    cout << ""Count = ""
         << countQuadruples(arr1, arr2, arr3,
                            arr4, n, x);
    return 0;
}",np,nlogn,nlogn,0,nlogn
45,"// C++ implementation to count triplets in a sorted doubly linked list
// whose sum is equal to a given value 'x'
#include <bits/stdc++.h>
  
using namespace std;
  
// structure of node of doubly linked list
struct Node {
    int data;
    struct Node* next, *prev;
};
  
// function to count triplets in a sorted doubly linked list
// whose sum is equal to a given value 'x'
int countTriplets(struct Node* head, int x)
{
    struct Node* ptr, *ptr1, *ptr2;
    int count = 0;
  
    // unordered_map 'um' implemented as hash table
    unordered_map<int, Node*> um;
  
    // insert the <node data, node pointer> tuple in 'um'
    for (ptr = head; ptr != NULL; ptr = ptr->next)
        um[ptr->data] = ptr;
  
    // generate all possible pairs
    for (ptr1 = head; ptr1 != NULL; ptr1 = ptr1->next)
        for (ptr2 = ptr1->next; ptr2 != NULL; ptr2 = ptr2->next) {
  
            // p_sum - sum of elements in the current pair
            int p_sum = ptr1->data + ptr2->data;
  
            // if 'x-p_sum' is present in 'um' and either of the two nodes
            // are not equal to the 'um[x-p_sum]' node
            if (um.find(x - p_sum) != um.end() && um[x - p_sum] != ptr1
                && um[x - p_sum] != ptr2)
  
                // increment count
                count++;
        }
  
    // required count of triplets
    // division by 3 as each triplet is counted 3 times
    return (count / 3);
}
  
// A utility function to insert a new node at the
// beginning of doubly linked list
void insert(struct Node** head, int data)
{
    // allocate node
    struct Node* temp = new Node();
  
    // put in the data
    temp->data = data;
    temp->next = temp->prev = NULL;
  
    if ((*head) == NULL)
        (*head) = temp;
    else {
        temp->next = *head;
        (*head)->prev = temp;
        (*head) = temp;
    }
}
  
// Driver program to test above
int main()
{
    // start with an empty doubly linked list
    struct Node* head = NULL;
  
    // insert values in sorted order
    insert(&head, 9);
    insert(&head, 8);
    insert(&head, 6);
    insert(&head, 5);
    insert(&head, 4);
    insert(&head, 2);
    insert(&head, 1);
  
    int x = 17;
  
    cout << ""Count = ""
         << countTriplets(head, x);
    return 0;
}",quadratic,nlogn,nlogn,0,nlogn
46,"/* C++ program to insetail nodes in doubly
linked list such that list remains in
ascending order on printing from left
to right */
#include <bits/stdc++.h>
using namespace std;
 
// A linked list node
class Node
{
    public:
    Node *prev;
    int info;
    Node *next;
};
 
// Function to insetail new node
void nodeInsetail(Node **head,
                Node **tail,
                int key)
{
 
    Node *p = new Node();
    p->info = key;
    p->next = NULL;
 
    // If first node to be insetailed in doubly
    // linked list
    if ((*head) == NULL)
    {
        (*head) = p;
        (*tail) = p;
        (*head)->prev = NULL;
        return;
    }
 
    // If node to be insetailed has value less
    // than first node
    if ((p->info) < ((*head)->info))
    {
        p->prev = NULL;
        (*head)->prev = p;
        p->next = (*head);
        (*head) = p;
        return;
    }
 
    // If node to be insetailed has value more
    // than last node
    if ((p->info) > ((*tail)->info))
    {
        p->prev = (*tail);
        (*tail)->next = p;
        (*tail) = p;
        return;
    }
 
    // Find the node before which we need to
    // insert p.
    Node *temp = (*head)->next;
    while ((temp->info) < (p->info))
        temp = temp->next;
 
    // Insert new node before temp
    (temp->prev)->next = p;
    p->prev = temp->prev;
    temp->prev = p;
    p->next = temp;
}
 
// Function to print nodes in from left to right
void printList(Node *temp)
{
    while (temp != NULL)
    {
        cout << temp->info << "" "";
        temp = temp->next;
    }
}
 
// Driver program to test above functions
int main()
{
    Node *left = NULL, *right = NULL;
    nodeInsetail(&left, &right, 30);
    nodeInsetail(&left, &right, 50);
    nodeInsetail(&left, &right, 90);
    nodeInsetail(&left, &right, 10);
    nodeInsetail(&left, &right, 40);
    nodeInsetail(&left, &right, 110);
    nodeInsetail(&left, &right, 60);
    nodeInsetail(&left, &right, 95);
    nodeInsetail(&left, &right, 23);
 
    cout<<""Doubly linked list on printing""
        "" from left to right\n"";
    printList(left);
 
    return 0;
}
 
// This is code is contributed by rathbhupendra",linear,quadratic,quadratic,0,quadratic
47,"#include <bits/stdc++.h>
using namespace std;
 
/**
 * Reverse Row at specified index in the matrix
 * @param data matrix
 * @param index row index
 */
void reverseRow(vector<vector<int>>& data,
                int index)
{
    int cols = data[index].size();
    for(int i = 0; i < cols / 2; i++)
    {
        int temp = data[index][i];
        data[index][i] = data[index][cols - i - 1];
        data[index][cols - i - 1] = temp;
    }
}
 
/**
 * Print Matrix data
 * @param data matrix
 */
void printMatrix(vector<vector<int>>& data)
{
    for(int i = 0; i < data.size(); i++)
    {
        for(int j = 0; j < data[i].size(); j++)
        {
            cout << data[i][j] << "" "";
        }
        cout << endl;
    }
}
 
/**
 * Rotate Matrix by 180 degrees
 * @param data matrix
 */
void rotateMatrix180(vector<vector<int>>& data)
{
    int rows = data.size();
    int cols = data[0].size();
 
    if (rows % 2 != 0)
    {
         
        // If N is odd reverse the middle
        // row in the matrix
        reverseRow(data, data.size() / 2);
    }
     
    // Swap the value of matrix [i][j] with
    // [rows - i - 1][cols - j - 1] for half    
    // the rows size.
    for(int i = 0; i <= (rows/2) - 1; i++)
    {
        for(int j = 0; j < cols; j++)
        {
            int temp = data[i][j];
            data[i][j] = data[rows - i - 1][cols - j - 1];
            data[rows - i - 1][cols - j - 1] = temp;
        }
    }
}
 
// Driver code   
int main()
{
    vector<vector<int>> data{ { 1, 2, 3, 4, 5 },
                              { 6, 7, 8, 9, 10 },
                              { 11, 12, 13, 14, 15 },
                              { 16, 17, 18, 19, 20 },
                              { 21, 22, 23, 24, 25 } };
 
    // Rotate Matrix
    rotateMatrix180(data);
 
    // Print Matrix
    printMatrix(data);
 
    return 0;
}
 
// This code is contributed by divyeshrabadiya07",quadratic,quadratic,quadratic,1,quadratic
48,"// CPP program for finding max path in matrix
#include <bits/stdc++.h>
#define N 4
#define M 6
using namespace std;
 
// To calculate max path in matrix
int findMaxPath(int mat[][M])
{
 
    for (int i = 1; i < N; i++) {
        for (int j = 0; j < M; j++) {
 
            // When all paths are possible
            if (j > 0 && j < M - 1)
                mat[i][j] += max(mat[i - 1][j],
                             max(mat[i - 1][j - 1],
                             mat[i - 1][j + 1]));
 
            // When diagonal right is not possible
            else if (j > 0)
                mat[i][j] += max(mat[i - 1][j],
                            mat[i - 1][j - 1]);
 
            // When diagonal left is not possible
            else if (j < M - 1)
                mat[i][j] += max(mat[i - 1][j],
                            mat[i - 1][j + 1]);
 
            // Store max path sum
        }
    }
    int res = 0;
    for (int j = 0; j < M; j++)
        res = max(mat[N-1][j], res);
    return res;
}
 
// Driver program to check findMaxPath
int main()
{
     
    int mat1[N][M] = { { 10, 10, 2, 0, 20, 4 },
                    { 1, 0, 0, 30, 2, 5 },
                    { 0, 10, 4, 0, 2, 0 },
                    { 1, 0, 2, 20, 0, 4 } };
             
    cout << findMaxPath(mat1) << endl;
    return 0;
}",quadratic,nlogn,nlogn,0,nlogn
49,"// C++ implementation to count sub-matrices having sum
// divisible by the value 'k'
#include <bits/stdc++.h>
using namespace std;
 
#define SIZE 10
 
// function to count all sub-arrays divisible by k
int subCount(int arr[], int n, int k)
{
    // create auxiliary hash array to count frequency
    // of remainders
    int mod[k];
    memset(mod, 0, sizeof(mod));
 
    // Traverse original array and compute cumulative
    // sum take remainder of this current cumulative
    // sum and increase count by 1 for this remainder
    // in mod[] array
    int cumSum = 0;
    for (int i = 0; i < n; i++) {
        cumSum += arr[i];
 
        // as the sum can be negative, taking modulo
        // twice
        mod[((cumSum % k) + k) % k]++;
    }
 
    int result = 0; // Initialize result
 
    // Traverse mod[]
    for (int i = 0; i < k; i++)
 
        // If there are more than one prefix subarrays
        // with a particular mod value.
        if (mod[i] > 1)
            result += (mod[i] * (mod[i] - 1)) / 2;
 
    // add the subarrays starting from the arr[i]
    // which are divisible by k itself
    result += mod[0];
 
    return result;
}
 
// function to count all sub-matrices having sum
// divisible by the value 'k'
int countSubmatrix(int mat[SIZE][SIZE], int n, int k)
{
    // Variable to store the final output
    int tot_count = 0;
 
    int left, right, i;
    int temp[n];
 
    // Set the left column
    for (left = 0; left < n; left++) {
 
        // Initialize all elements of temp as 0
        memset(temp, 0, sizeof(temp));
 
        // Set the right column for the left column
        // set by outer loop
        for (right = left; right < n; right++) {
 
            // Calculate sum between current left 
            // and right for every row 'i'
            for (i = 0; i < n; ++i)
                temp[i] += mat[i][right];
 
            // Count number of subarrays in temp[]
            // having sum divisible by 'k' and then
            // add it to 'tot_count'
            tot_count += subCount(temp, n, k);
        }
    }
 
    // required count of sub-matrices having sum
    // divisible by 'k'
    return tot_count;
}
 
// Driver program to test above
int main()
{
    int mat[][SIZE] = { { 5, -1, 6 },
                        { -2, 3, 8 },
                        { 7, 4, -9 } };
    int n = 3, k = 4;
    cout << ""Count = ""
         << countSubmatrix(mat, n, k);
    return 0;
}",cubic,nlogn,nlogn,0,nlogn
50,"// C++ program to search an element in row-wise
// and column-wise sorted matrix
#include <bits/stdc++.h>
 
using namespace std;
 
/* Searches the element x in mat[][]. If the
element is found, then prints its position
and returns true, otherwise prints ""not found""
and returns false */
int search(int mat[4][4], int n, int x)
{
    if (n == 0)
        return -1;
 
    // traverse through the matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            // if the element is found
            if (mat[i][j] == x) {
                cout << ""Element found at ("" << i << "", ""
                     << j << "")\n"";
                return 1;
            }
    }
 
    cout << ""n Element not found"";
    return 0;
}
 
// Driver code
int main()
{
    int mat[4][4] = { { 10, 20, 30, 40 },
                      { 15, 25, 35, 45 },
                      { 27, 29, 37, 48 },
                      { 32, 33, 39, 50 } };
 
    // Function call
    search(mat, 4, 29);
 
    return 0;
}
 
// This code is contributed by Aditya Kumar (adityakumar129)",quadratic,quadratic,quadratic,1,quadratic
51,"// C++ program to find sum of matrix in which
// each element is absolute difference of its
// corresponding row and column number row.
#include<bits/stdc++.h>
using namespace std;
 
// Return the sum of matrix in which each element
// is absolute difference of its corresponding
// row and column number row
int findSum(int n)
{
    n--;
    int sum = 0;
    sum += (n*(n+1))/2;
    sum += (n*(n+1)*(2*n + 1))/6;
    return sum;
}
 
// Driven Program
int main()
{
    int n = 3;
    cout << findSum(n) << endl;
    return 0;
}",constant,quadratic,quadratic,0,quadratic
52,"// C++ program to find  maximum possible determinant
// of 0/n matrix.
#include <bits/stdc++.h>
using namespace std;
 
// Function for maximum determinant
int maxDet(int n)
{
    return (2*n*n*n);
}
 
// Function to print resultant matrix
void resMatrix ( int n)
{
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            // three position where 0 appears
            if (i == 0 && j == 2)
                cout << ""0 "";
            else if (i == 1 && j == 0)
                cout << ""0 "";
            else if (i == 2 && j == 1)
                cout << ""0 "";
 
            // position where n appears
            else
                cout << n << "" "";
        }
        cout << ""\n"";
    }
}
 
// Driver code
int main()
{
    int n = 15;
    cout << ""Maximum Determinant = "" << maxDet(n);
 
    cout << ""\nResultant Matrix :\n"";
    resMatrix(n);
 
    return 0;
}",constant,cubic,cubic,0,cubic
53,"// C++ program to find a pair with given sum such that
// every element of pair is in different rows.
#include<bits/stdc++.h>
using namespace std;
 
const int MAX = 100;
 
// Function to find pair for given sum in matrix
// mat[][] --> given matrix
// n --> order of matrix
// sum --> given sum for which we need to find pair
void pairSum(int mat[][MAX], int n, int sum)
{
    // First sort all the rows in ascending order
    for (int i=0; i<n; i++)
        sort(mat[i], mat[i]+n);
 
    // Select i'th row and find pair for element in i'th
    // row in j'th row whose summation is equal to given sum
    for (int i=0; i<n-1; i++)
    {
        for (int j=i+1; j<n; j++)
        {
            int left = 0, right = n-1;
            while (left<n && right>=0)
            {
                if ((mat[i][left] + mat[j][right]) == sum)
                {
                    cout << ""("" << mat[i][left]
                         << "", ""<< mat[j][right] << ""), "";
                    left++;
                    right--;
                }
                else
                {
                    if ((mat[i][left] + mat[j][right]) < sum)
                        left++;
                    else
                        right--;
                }
            }
        }
    }
}
 
// Driver program to run the case
int main()
{
    int n = 4, sum = 11;
    int mat[][MAX] = {{1, 3, 2, 4},
                      {5, 8, 7, 6},
                      {9, 10, 13, 11},
                      {12, 0, 14, 15}};
    pairSum(mat, n, sum);
    return 0;
}",cubic,nlogn,nlogn,0,nlogn
54,"// A Naive method to find maximum value of mat[d][e]
// - ma[a][b] such that d > a and e > b
#include <bits/stdc++.h>
using namespace std;
#define N 5
 
// The function returns maximum value A(d,e) - A(a,b)
// over all choices of indexes such that both d > a
// and e > b.
int findMaxValue(int mat[][N])
{
    // stores maximum value
    int maxValue = INT_MIN;
 
    // Consider all possible pairs mat[a][b] and
    // mat[d][e]
    for (int a = 0; a < N - 1; a++)
    for (int b = 0; b < N - 1; b++)
        for (int d = a + 1; d < N; d++)
        for (int e = b + 1; e < N; e++)
            if (maxValue < (mat[d][e] - mat[a][b]))
                maxValue = mat[d][e] - mat[a][b];
 
    return maxValue;
}
 
// Driver program to test above function
int main()
{
int mat[N][N] = {
                { 1, 2, -1, -4, -20 },
                { -8, -3, 4, 2, 1 },
                { 3, 8, 6, 1, 3 },
                { -4, -1, 1, 7, -6 },
                { 0, -4, 10, -5, 1 }
            };
    cout << ""Maximum Value is ""
        << findMaxValue(mat);
 
    return 0;
}",np,nlogn,nlogn,0,nlogn
55,"#include <bits/stdc++.h>
using namespace std;
 
struct QNode {
    int data;
    QNode* next;
    QNode(int d)
    {
        data = d;
        next = NULL;
    }
};
 
struct Queue {
    QNode *front, *rear;
    Queue() { front = rear = NULL; }
 
    void enQueue(int x)
    {
 
        // Create a new LL node
        QNode* temp = new QNode(x);
 
        // If queue is empty, then
        // new node is front and rear both
        if (rear == NULL) {
            front = rear = temp;
            return;
        }
 
        // Add the new node at
        // the end of queue and change rear
        rear->next = temp;
        rear = temp;
    }
 
    // Function to remove
    // a key from given queue q
    void deQueue()
    {
        // If queue is empty, return NULL.
        if (front == NULL)
            return;
 
        // Store previous front and
        // move front one node ahead
        QNode* temp = front;
        front = front->next;
 
        // If front becomes NULL, then
        // change rear also as NULL
        if (front == NULL)
            rear = NULL;
 
        delete (temp);
    }
};
 
// Driven Program
int main()
{
 
    Queue q;
    q.enQueue(10);
    q.enQueue(20);
    q.deQueue();
    q.deQueue();
    q.enQueue(30);
    q.enQueue(40);
    q.enQueue(50);
    q.deQueue();
    cout << ""Queue Front : "" << (q.front)->data << endl;
    cout << ""Queue Rear : "" << (q.rear)->data;
}
// This code is contributed by rathbhupendra",constant,quadratic,quadratic,0,quadratic
56,"// C++ program to implement a stack using
// Priority queue(min heap)
#include<bits/stdc++.h>
using namespace std;
 
typedef pair<int, int> pi;
 
// User defined stack class
class Stack{
     
    // cnt is used to keep track of the number of
    //elements in the stack and also serves as key
    //for the priority queue.
    int cnt;
    priority_queue<pair<int, int> > pq;
public:
    Stack():cnt(0){}
    void push(int n);
    void pop();
    int top();
    bool isEmpty();
};
 
// push function increases cnt by 1 and
// inserts this cnt with the original value.
void Stack::push(int n){
    cnt++;
    pq.push(pi(cnt, n));
}
 
// pops element and reduces count.
void Stack::pop(){
    if(pq.empty()){ cout<<""Nothing to pop!!!"";}
    cnt--;
    pq.pop();
}
 
// returns the top element in the stack using
// cnt as key to determine top(highest priority),
// default comparator for pairs works fine in this case
int Stack::top(){
    pi temp=pq.top();
    return temp.second;
}
 
// return true if stack is empty
bool Stack::isEmpty(){
    return pq.empty();
}
 
// Driver code
int main()
{
    Stack* s=new Stack();
    s->push(1);
    s->push(2);
    s->push(3);
    while(!s->isEmpty()){
        cout<<s->top()<<endl;
        s->pop();
    }
}",logn,n,linear,0,n
57,"// program to demonstrate customized data structure
// which supports functions in O(1)
#include <iostream>
#include <vector>
using namespace std;
const int MAXX = 1000;
 
// class stack
class stack {
    int minn;
    int size;
 
public:
    stack()
    {
        minn = 99999;
        size = -1;
    }
    vector<pair<int, int> > arr;
    int GetLastElement();
    int RemoveLastElement();
    int AddElement(int element);
    int GetMin();
};
 
// utility function for adding a new element
int stack::AddElement(int element)
{
    if (size > MAXX) {
        cout << ""stack overflow, max size reached!\n"";
        return 0;
    }
    if (element < minn)
        minn = element;
    arr.push_back(make_pair(element, minn));
    size++;
    return 1;
}
 
// utility function for returning last element of stack
int stack::GetLastElement()
{
    if (size == -1) {
        cout << ""No elements in stack\n"";
        return 0;
    }
    return arr[size].first;
}
 
// utility function for removing last element successfully;
int stack::RemoveLastElement()
{
    if (size == -1) {
        cout << ""stack empty!!!\n"";
        return 0;
    }
 
    // updating minimum element
    if (size > 0 && arr[size - 1].second > arr[size].second) {
        minn = arr[size - 1].second;
    }
    arr.pop_back();
    size -= 1;
    return 1;
}
 
// utility function for returning min element till now;
int stack::GetMin()
{
    if (size == -1) {
        cout << ""stack empty!!\n"";
        return 0;
    }
    return arr[size].second;
}
 
// Driver code
int main()
{
    stack s;
    int success = s.AddElement(5);
    if (success == 1)
        cout << ""5 inserted successfully\n"";
 
    success = s.AddElement(7);
    if (success == 1)
        cout << ""7 inserted successfully\n"";
 
    success = s.AddElement(3);
    if (success == 1)
        cout << ""3 inserted successfully\n"";
    int min1 = s.GetMin();
    cout << ""min element  :: "" << min1 << endl;
 
    success = s.RemoveLastElement();
    if (success == 1)
        cout << ""removed successfully\n"";
 
    success = s.AddElement(2);
    if (success == 1)
        cout << ""2 inserted successfully\n"";
 
    success = s.AddElement(9);
    if (success == 1)
        cout << ""9 inserted successfully\n"";
    int last = s.GetLastElement();
    cout << ""Last element :: "" << last << endl;
 
    success = s.AddElement(0);
    if (success == 1)
        cout << ""0 inserted successfully\n"";
    min1 = s.GetMin();
    cout << ""min element  :: "" << min1 << endl;
 
    success = s.RemoveLastElement();
    if (success == 1)
        cout << ""removed successfully\n"";
 
    success = s.AddElement(11);
    if (success == 1)
        cout << ""11 inserted successfully\n"";
    min1 = s.GetMin();
    cout << ""min element  :: "" << min1 << endl;
 
    return 0;
}",constant,nlogn,nlogn,0,nlogn
58,"// C++ program to evaluate value of a postfix expression
#include <iostream>
#include <string.h>
 
using namespace std;
 
// Stack type
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};
 
// Stack Operations
struct Stack* createStack( unsigned capacity )
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
 
    if (!stack) return NULL;
 
    stack->top = -1;
    stack->capacity = capacity;
    stack->array = (int*) malloc(stack->capacity * sizeof(int));
 
    if (!stack->array) return NULL;
 
    return stack;
}
 
int isEmpty(struct Stack* stack)
{
    return stack->top == -1 ;
}
 
char peek(struct Stack* stack)
{
    return stack->array[stack->top];
}
 
char pop(struct Stack* stack)
{
    if (!isEmpty(stack))
        return stack->array[stack->top--] ;
    return '$';
}
 
void push(struct Stack* stack, char op)
{
    stack->array[++stack->top] = op;
}
 
 
// The main function that returns value of a given postfix expression
int evaluatePostfix(char* exp)
{
    // Create a stack of capacity equal to expression size
    struct Stack* stack = createStack(strlen(exp));
    int i;
 
    // See if stack was created successfully
    if (!stack) return -1;
 
    // Scan all characters one by one
    for (i = 0; exp[i]; ++i)
    {
        // If the scanned character is an operand (number here),
        // push it to the stack.
        if (isdigit(exp[i]))
            push(stack, exp[i] - '0');
 
        // If the scanned character is an operator, pop two
        // elements from stack apply the operator
        else
        {
            int val1 = pop(stack);
            int val2 = pop(stack);
            switch (exp[i])
            {
            case '+': push(stack, val2 + val1); break;
            case '-': push(stack, val2 - val1); break;
            case '*': push(stack, val2 * val1); break;
            case '/': push(stack, val2/val1); break;
            }
        }
    }
    return pop(stack);
}
 
// Driver program to test above functions
int main()
{
    char exp[] = ""231*+9-"";
    cout<<""postfix evaluation: ""<< evaluatePostfix(exp);
    return 0;
}",linear,n,linear,1,n
59,"// C++ program to delete elements from array.
#include <bits/stdc++.h>
using namespace std;
 
// Function for deleting k elements
void deleteElements(int arr[], int n, int k)
{
    // Create a stack and push arr[0]
    stack<int> s;
    s.push(arr[0]);
 
    int count = 0;
     
    // traversing a loop from i = 1 to n
    for (int i=1; i<n; i++) {
         
        // condition for deleting an element
        while (!s.empty() && s.top() < arr[i]
                            && count < k) {                                    
            s.pop();
            count++;
        }
         
        s.push(arr[i]);
    }
     
    // Putting elements of stack in a vector
    // from end to begin.
    int m = s.size();
    vector<int> v(m); // Size of vector is m
    while (!s.empty()) {
         
        // push element from stack to vector v
        v[--m] = s.top();
        s.pop();
    }
     
    // printing result
    for (auto x : v)
        cout << x << "" "";
         
    cout << endl;
}
 
// Driver code
int main()
{
    int n = 5, k = 2;
    int arr[] = {20, 10, 25, 30, 40};
    deleteElements(arr, n, k);
    return 0;
}",quadratic,quadratic,quadratic,1,quadratic
60,"// C++ program to determine whether given
// expression is balanced/ parenthesis
// expression or not.
#include <bits/stdc++.h>
using namespace std;
 
// Function to check if two brackets are matching
// or not.
int isMatching(char a, char b)
{
    if ((a == '{' && b == '}') || (a == '[' && b == ']')
        || (a == '(' && b == ')') || a == 'X')
        return 1;
    return 0;
}
 
// Recursive function to check if given expression
// is balanced or not.
int isBalanced(string s, stack<char> ele, int ind)
{
 
    // Base case.
    // If the string is balanced then all the opening
    // brackets had been popped and stack should be
    // empty after string is traversed completely.
    if (ind == s.length())
        return ele.empty();
 
    // variable to store element at the top of the stack.
    char topEle;
 
    // variable to store result of recursive call.
    int res;
 
    // Case 1: When current element is an opening bracket
    // then push that element in the stack.
    if (s[ind] == '{' || s[ind] == '(' || s[ind] == '[') {
        ele.push(s[ind]);
        return isBalanced(s, ele, ind + 1);
    }
 
    // Case 2: When current element is a closing bracket
    // then check for matching bracket at the top of the
    // stack.
    else if (s[ind] == '}' || s[ind] == ')' || s[ind] == ']') {
 
        // If stack is empty then there is no matching opening
        // bracket for current closing bracket and the
        // expression is not balanced.
        if (ele.empty())
            return 0;
 
        topEle = ele.top();
        ele.pop();
 
        // Check bracket is matching or not.
        if (!isMatching(topEle, s[ind]))
            return 0;
         
        return isBalanced(s, ele, ind + 1);
    }
 
    // Case 3: If current element is 'X' then check
    // for both the cases when 'X' could be opening
    // or closing bracket.
    else if (s[ind] == 'X') {
        stack<char> tmp = ele;
        tmp.push(s[ind]);
        res = isBalanced(s, tmp, ind + 1);
        if (res)
            return 1;
        if (ele.empty())
            return 0;
        ele.pop();
        return isBalanced(s, ele, ind + 1);
    }
}
 
int main()
{
    string s = ""{(X}[]"";
    stack<char> ele;
   
     //Check if the String is of even length
      if(s.length()%2==0){
        if (isBalanced(s, ele, 0))
            cout << ""Balanced"";   
        else
            cout << ""Not Balanced"";
    }
   
      // If the length of the string is not even
      // then it is not a balanced string
      else{
          cout << ""Not Balanced"";
      }
    return 0;
}",np,n,linear,0,n
61,"// C++ program to find maximum and minimum
// possible sums of two numbers that we can
// get if replacing digit from 5 to 6 and vice
// versa are allowed.
#include<bits/stdc++.h>
using namespace std;
 
// Find new value of x after replacing digit
// ""from"" to ""to""
int replaceDig(int x, int from, int to)
{
    int result = 0;
    int multiply = 1;
 
    while (x > 0)
    {
        int reminder = x % 10;
 
        // Required digit found, replace it
        if (reminder == from)
            result = result + to * multiply;
 
        else
            result = result + reminder * multiply;
 
        multiply *= 10;
        x = x / 10;
    }
    return result;
}
 
// Returns maximum and minimum possible sums of
// x1 and x2 if digit replacements are allowed.
void calculateMinMaxSum(int x1, int x2)
{
    // We always get minimum sum if we replace
    // 6 with 5.
    int minSum = replaceDig(x1, 6, 5) +
                 replaceDig(x2, 6, 5);
 
    // We always get maximum sum if we replace
    // 5 with 6.
    int maxSum = replaceDig(x1, 5, 6) +
                 replaceDig(x2, 5, 6);
    cout << ""Minimum sum = "" << minSum;
    cout << ""nMaximum sum = "" << maxSum;
}
 
// Driver code
int main()
{
    int x1 = 5466, x2 = 4555;
    calculateMinMaxSum(x1, x2);
    return 0;
}",logn,nlogn,nlogn,0,nlogn
62,"// C++ program to implement division with large
// number
#include <bits/stdc++.h>
using namespace std;
 
// A function to perform division of large numbers
string longDivision(string number, int divisor)
{
    // As result can be very large store it in string
    string ans;
 
    // Find prefix of number that is larger
    // than divisor.
    int idx = 0;
    int temp = number[idx] - '0';
    while (temp < divisor)
        temp = temp * 10 + (number[++idx] - '0');
 
    // Repeatedly divide divisor with temp. After
    // every division, update temp to include one
    // more digit.
    while (number.size() > idx) {
        // Store result in answer i.e. temp / divisor
        ans += (temp / divisor) + '0';
 
        // Take next digit of number
        temp = (temp % divisor) * 10 + number[++idx] - '0';
    }
 
    // If divisor is greater than number
    if (ans.length() == 0)
        return ""0"";
 
    // else return ans
    return ans;
}
 
// Driver program to test longDivision()
int main()
{
    string number = ""1248163264128256512"";
    int divisor = 125;
    cout << longDivision(number, divisor);
    return 0;
}",np,quadratic,quadratic,0,quadratic
63,"#include <bits/stdc++.h>
using namespace std;
 
// Function
string Minimum_Window(string s, string t)
{
 
    int m[256] = { 0 };
 
    // Answer
    int ans = INT_MAX; // length of ans
    int start = 0; // starting index of ans
    int count = 0;
 
    // creating map
    for (int i = 0; i < t.length(); i++) {
        if (m[t[i]] == 0)
            count++;
        m[t[i]]++;
    }
 
    // References of Window
    int i = 0;
    int j = 0;
 
    // Traversing the window
    while (j < s.length()) {
        // Calculations
        m[s[j]]--;
        if (m[s[j]] == 0)
            count--;
 
        // Condition matching
        if (count == 0) {
            while (count == 0) {
                // Sorting ans
                if (ans > j - i + 1) {
                    ans = min(ans, j - i + 1);
                    start = i;
                }
                // Sliding I
                // Calculation for removing I
 
                m[s[i]]++;
                if (m[s[i]] > 0)
                    count++;
 
                i++;
            }
        }
        j++;
    }
 
    if (ans != INT_MAX)
        return s.substr(start, ans);
    else
        return ""-1"";
}
 
int main()
{
    string s = ""this is a test string"";
    string t = ""tist"";
 
    cout << Minimum_Window(s, t);
    return 0;
}",linear,n,linear,1,n
64,"#include<bits/stdc++.h>
using namespace std;
 
string UncommonChars(string a, string b)
{
    int mp1[26] = {0}, mp2[26] = {0};
    int n = a.size(), m = b.size();
 
    for(auto &x: a){
      mp1[x-'a'] = 1;
    }
 
    for(auto &x: b){
      mp2[x-'a'] = 1;
    }
 
    string chars = """";
 
    for(int i = 0; i < 26; ++i){
      if(mp1[i]^mp2[i])
        chars+=char(i+'a');
    }
    if(chars == """")
      return ""-1"";
    else
      return chars;
}
 
int main(){
    string a = ""geeksforgeeks"";
    string b = ""geeksquiz"";
    string result = UncommonChars(a,b);
    cout << result << endl;
    return 0;
}",linear,n,linear,1,n
65,"// C++ program Find concatenated string with
// uncommon characters of given strings
#include <bits/stdc++.h>
using namespace std;
 
string concatenatedString(string s1, string s2)
{
    string res = """"; // result
 
    // store all characters of s2 in map
    unordered_map<char, int> m;
    for (int i = 0; i < s2.size(); i++)
        m[s2[i]] = 1;
 
    // Find characters of s1 that are not
    // present in s2 and append to result
    for (int i = 0; i < s1.size(); i++) {
        if (m.find(s1[i]) == m.end())
            res += s1[i];
        else
            m[s1[i]] = 2;
    }
 
    // Find characters of s2 that are not
    // present in s1.
    for (int i = 0; i < s2.size(); i++)
        if (m[s2[i]] == 1)
            res += s2[i];
    return res;
}
 
/* Driver program to test above function */
int main()
{
    string s1 = ""abcs"";
    string s2 = ""cxzca"";
    cout << concatenatedString(s1, s2);
    return 0;
}",linear,n,linear,1,n
66,"// C++ program to Find longest subsequence where every
// character appears at-least k times
#include <bits/stdc++.h>
using namespace std;
 
void longestSubseqWithK(string str, int k)
{
    int n = str.size();
    map<char, int> mp;
 
    // Count frequencies of all characters
    for (int i = 0; i < n; i++) {
        char t = str[i];
        mp[t]++;
    }
 
    // Traverse given string again and print
    // all those characters whose frequency
    // is more than or equal to k.
    for (int i = 0; i < n; i++) {
        char t = str[i];
        if (mp[t] >= k) {
            cout << t;
        }
    }
}
 
// Driver code
int main()
{
    string str = ""geeksforgeeks"";
    int k = 2;
    longestSubseqWithK(str, k);
 
    return 0;
}
 
// This code is contributed by rakeshsahni",nlogn,n,linear,0,n
67,"// C++ program to count all rotation divisible
// by 4.
#include <bits/stdc++.h>
using namespace std;
 
// Returns count of all rotations divisible
// by 4
int countRotations(string n)
{
    int len = n.length();
 
    // For single digit number
    if (len == 1)
    {
        int oneDigit = n.at(0)-'0';
        if (oneDigit%4 == 0)
            return 1;
        return 0;
    }
 
    // At-least 2 digit number (considering all
    // pairs)
    int twoDigit, count = 0;
    for (int i=0; i<(len-1); i++)
    {
        twoDigit = (n.at(i)-'0')*10 + (n.at(i+1)-'0');
        if (twoDigit%4 == 0)
            count++;
    }
 
    // Considering the number formed by the pair of
    // last digit and 1st digit
    twoDigit = (n.at(len-1)-'0')*10 + (n.at(0)-'0');
    if (twoDigit%4 == 0)
        count++;
 
    return count;
}
 
//Driver program
int main()
{
    string n = ""4834"";
    cout << ""Rotations: "" << countRotations(n) << endl;
    return 0;
}",linear,n,linear,1,n
68,"// C++ program to check if all rows of a matrix
// are rotations of each other
#include <bits/stdc++.h>
using namespace std;
const int MAX = 1000;
 
// Returns true if all rows of mat[0..n-1][0..n-1]
// are rotations of each other.
bool isPermutedMatrix( int mat[MAX][MAX], int n)
{
    // Creating a string that contains elements of first
    // row.
    string str_cat = """";
    for (int i = 0 ; i < n ; i++)
        str_cat = str_cat + ""-"" + to_string(mat[0][i]);
 
    // Concatenating the string with itself so that
    // substring search operations can be performed on
    // this
    str_cat = str_cat + str_cat;
 
    // Start traversing remaining rows
    for (int i=1; i<n; i++)
    {
        // Store the matrix into vector in the form
        // of strings
        string curr_str = """";
        for (int j = 0 ; j < n ; j++)
            curr_str = curr_str + ""-"" + to_string(mat[i][j]);
 
        // Check if the current string is present in
        // the concatenated string or not
        if (str_cat.find(curr_str) == string::npos)
            return false;
    }
 
    return true;
}
 
// Drivers code
int main()
{
    int n = 4 ;
    int mat[MAX][MAX] = {{1, 2, 3, 4},
        {4, 1, 2, 3},
        {3, 4, 1, 2},
        {2, 3, 4, 1}
    };
    isPermutedMatrix(mat, n)? cout << ""Yes"" :
                              cout << ""No"";
    return 0;
}",cubic,nlogn,nlogn,0,nlogn
69,"// CPP program to sort a string in descending
// order using library function
#include <bits/stdc++.h>
using namespace std;
 
void descOrder(string &s)
{
    sort(s.begin(), s.end(), greater<char>());
}
 
int main()
{
    string s = ""geeksforgeeks"";
    descOrder(s); // function call
    for(int i = 0; i <  s.size(); i++)
      cout << s[i];
    return 0;
}",constant,quadratic,quadratic,0,quadratic
70,"// CPP code to print all permutations
// with respect to cases
#include <bits/stdc++.h>
using namespace std;
 
// Function to generate permutations
void permute(string ip, string op)
{
    // base case
    if (ip.size() == 0) {
        cout << op << "" "";
        return;
    }
    // pick lower and uppercase
    char ch = tolower(ip[0]);
    char ch2 = toupper(ip[0]);
    ip = ip.substr(1);
 
    permute(ip, op + ch);
    permute(ip, op + ch2);
}
 
// Driver code
int main()
{
    string ip = ""aB"";
    permute(ip, """");
    return 0;
}",np,n,linear,0,n
71,"// Finds maximum occurring digit without using any array/string
#include <bits/stdc++.h>
using namespace std;
 
// Simple function to count occurrences of digit d in x
int countOccurrences(long int x, int d)
{
    int count = 0;  // Initialize count of digit d
    while (x)
    {
        // Increment count if current digit is same as d
        if (x%10 == d)
           count++;
        x = x/10;
    }
    return count;
}
 
// Returns the max occurring digit in x
int maxOccurring(long int x)
{
   // Handle negative number
   if (x < 0)
      x = -x;
 
   int result = 0; // Initialize result which is a digit
   int max_count = 1; // Initialize count of result
 
   // Traverse through all digits
   for (int d=0; d<=9; d++)
   {
      // Count occurrences of current digit
      int count = countOccurrences(x, d);
 
      // Update max_count and result if needed
      if (count >= max_count)
      {
         max_count = count;
         result = d;
      }
   }
   return result;
}
 
// Driver program
int main()
{
    long int x = 1223355;
    cout << ""Max occurring digit is "" << maxOccurring(x);
    return 0;
}",constant,n,linear,0,n
72,"// C++ program to check if binary
// representations of two numbers are anagrams.
#include <bits/stdc++.h>
 
using namespace std;
 
// Check each bit in a number is set or not
// and return the total count of the set bits.
int countSetBits(int n)
{
    int count = 0;
    while (n) {
        count += n & 1;
        n >>= 1;
    }
    return count;
}
 
bool areAnagrams(int A, int B)
{
    return countSetBits(A) == countSetBits(B);
}
 
// Driver code
int main()
{
    int a = 8, b = 4;
    cout << areAnagrams(a, b) << endl;
    return 0;
}
 
// This code is contributed by phasing17",constant,n,linear,0,n
73,"// C++ program to count total anagram
// substring of a string
#include <bits/stdc++.h>
using namespace std;
 
// Total number of lowercase characters
#define MAX_CHAR 26
 
// Utility method to return integer index
// of character 'c'
int toNum(char c)
{
    return (c - 'a');
}
 
// Returns count of total number of anagram
// substrings of string str
int countOfAnagramSubstring(string str)
{
    int N = str.length();
 
    // To store counts of substrings with given
    // set of frequencies.
    map<vector<int>, int> mp;
 
    // loop for starting index of substring
    for (int i=0; i<N; i++)
    {
        vector<int> freq(MAX_CHAR, 0);
 
        // loop for length of substring
        for (int j=i; j<N; j++)
        {
            // update freq array of current
            // substring
            freq[toNum(str[j])]++;
 
            // increase count corresponding
            // to this freq array
            mp[freq]++;
        }
    }
 
    // loop over all different freq array and
    // aggregate substring count
    int result = 0;
    for (auto it=mp.begin(); it!=mp.end(); it++)
    {
        int freq = it->second;
        result += ((freq) * (freq-1))/2;
    }
    return result;
}
 
//  Driver code to test above methods
int main()
{
    string str = ""xyyx"";
    cout << countOfAnagramSubstring(str) << endl;
    return 0;
}",quadratic,nlogn,nlogn,0,nlogn
74,"// C++ program to generate n-bit Gray codes
#include <iostream>
#include <string>
#include <vector>
using namespace std;
 
// This function generates all n bit Gray codes and prints the
// generated codes
void generateGrayarr(int n)
{
    // base case
    if (n <= 0)
        return;
 
    // 'arr' will store all generated codes
    vector<string> arr;
 
    // start with one-bit pattern
    arr.push_back(""0"");
    arr.push_back(""1"");
 
    // Every iteration of this loop generates 2*i codes from previously
    // generated i codes.
    int i, j;
    for (i = 2; i < (1<<n); i = i<<1)
    {
        // Enter the previously generated codes again in arr[] in reverse
        // order. Nor arr[] has double number of codes.
        for (j = i-1 ; j >= 0 ; j--)
            arr.push_back(arr[j]);
 
        // append 0 to the first half
        for (j = 0 ; j < i ; j++)
            arr[j] = ""0"" + arr[j];
 
        // append 1 to the second half
        for (j = i ; j < 2*i ; j++)
            arr[j] = ""1"" + arr[j];
    }
 
    // print contents of arr[]
    for (i = 0 ; i < arr.size() ; i++ )
        cout << arr[i] << endl;
}
 
// Driver program to test above function
int main()
{
    generateGrayarr(3);
    return 0;
}",np,quadratic,quadratic,0,quadratic
75,"// C++ implementation of the above approach
#include <bits/stdc++.h>
using namespace std;
 
void GreyCode(int n)
{
     // power of 2
    for (int i = 0; i < (1 << n); i++)
    {
        // Generating the decimal
        // values of gray code then using
        // bitset to convert them to binary form
        int val = (i ^ (i >> 1));
         
        // Using bitset
        bitset<32> r(val);
         
        // Converting to string
        string s = r.to_string();
        cout << s.substr(32 - n) << "" "";
    }
}
 
 
// Driver Code
int main()
{
    int n;
    n = 4;
   
    // Function call
    GreyCode(n);
    
    return 0;
}",np,quadratic,quadratic,0,quadratic
76,"// C++ program to print rank of
// string using next_permute()
#include <bits/stdc++.h>
using namespace std;
 
// Function to print rank of string
// using next_permute()
int findRank(string str)
{
    // store original string
    string orgStr = str;
 
    // Sort the string in lexicographically
    // ascending order
    sort(str.begin(), str.end());
 
    // Keep iterating until
    // we reach equality condition
    long int i = 1;
    do {
        // check for nth iteration
        if (str == orgStr)
            break;
 
        i++;
    } while (next_permutation(str.begin(), str.end()));
 
    // return iterator value
    return i;
}
 
// Driver code
int main()
{
    string str = ""GEEKS"";
    cout << findRank(str);
    return 0;
}",nlogn,nlogn,nlogn,1,nlogn
77,"// C++ program for space optimized
// solution of Word Wrap problem.
 
#include <bits/stdc++.h>
using namespace std;
 
// Function to find space optimized
// solution of Word Wrap problem.
void solveWordWrap(int arr[], int n, int k)
{
    int i, j;
 
    // Variable to store number of
    // characters in given line.
    int currlen;
 
    // Variable to store possible
    // minimum cost of line.
    int cost;
 
    // DP table in which dp[i] represents
    // cost of line starting with word
    // arr[i].
    int dp[n];
 
    // Array in which ans[i] store index
    // of last word in line starting with
    // word arr[i].
    int ans[n];
 
    // If only one word is present then
    // only one line is required. Cost
    // of last line is zero. Hence cost
    // of this line is zero. Ending point
    // is also n-1 as single word is
    // present.
    dp[n - 1] = 0;
    ans[n - 1] = n - 1;
 
    // Make each word first word of line
    // by iterating over each index in arr.
    for (i = n - 2; i >= 0; i--) {
        currlen = -1;
        dp[i] = INT_MAX;
 
        // Keep on adding words in current
        // line by iterating from starting
        // word upto last word in arr.
        for (j = i; j < n; j++) {
 
            // Update number of characters
            // in current line. arr[j] is
            // number of characters in
            // current word and 1
            // represents space character
            // between two words.
            currlen += (arr[j] + 1);
 
            // If limit of characters
            // is violated then no more
            // words can be added to
            // current line.
            if (currlen > k)
                break;
 
            // If current word that is
            // added to line is last
            // word of arr then current
            // line is last line. Cost of
            // last line is 0. Else cost
            // is square of extra spaces
            // plus cost of putting line
            // breaks in rest of words
            // from j+1 to n-1.
            if (j == n - 1)
                cost = 0;
            else
                cost = (k - currlen) * (k - currlen) + dp[j + 1];
 
            // Check if this arrangement gives
            // minimum cost for line starting
            // with word arr[i].
            if (cost < dp[i]) {
                dp[i] = cost;
                ans[i] = j;
            }
        }
    }
 
    // Print starting index and ending index
    // of words present in each line.
    i = 0;
    while (i < n) {
        cout << i + 1 << "" "" << ans[i] + 1 << "" "";
        i = ans[i] + 1;
    }
}
 
// Driver function
int main()
{
    int arr[] = { 3, 2, 2, 5 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int M = 6;
    solveWordWrap(arr, n, M);
    return 0;
}",quadratic,nlogn,nlogn,0,nlogn
78,"// CPP program to check if a
// given ISBN is valid or not
#include <bits/stdc++.h>
using namespace std;
 
bool isValidISBN(string& isbn)
{
    // length must be 10
    int n = isbn.length();
    if (n != 10)
        return false;
 
    // Computing weighted sum
    // of first 9 digits
    int sum = 0;
    for (int i = 0; i < 9; i++)
    {
        int digit = isbn[i] - '0';
        if (0 > digit || 9 < digit)
            return false;
        sum += (digit * (10 - i));
    }
 
    // Checking last digit.
    char last = isbn[9];
    if (last != 'X' && (last < '0' ||
                        last > '9'))
        return false;
 
    // If last digit is 'X', add 10
    // to sum, else add its value.
    sum += ((last == 'X') ? 10 :
                  (last - '0'));
 
    // Return true if weighted sum
    // of digits is divisible by 11.
    return (sum % 11 == 0);
}
 
// Driver code
int main()
{
    string isbn = ""007462542X"";
    if (isValidISBN(isbn))
        cout << ""Valid"";
    else
        cout << ""Invalid"";
    return 0;
}",constant,n,linear,0,n
79,"# Python Program to search an element
# in a sorted and pivoted array
 
# Searches an element key in a pivoted
# sorted array arrp[] of size n
def pivotedBinarySearch(arr, n, key):
 
    pivot = findPivot(arr, 0, n-1)
 
    # If we didn't find a pivot,
    # then array is not rotated at all
    if pivot == -1:
        return binarySearch(arr, 0, n-1, key)
 
    # If we found a pivot, then first
    # compare with pivot and then
    # search in two subarrays around pivot
    if arr[pivot] == key:
        return pivot
    if arr[0] <= key:
        return binarySearch(arr, 0, pivot-1, key)
    return binarySearch(arr, pivot + 1, n-1, key)
 
 
# Function to get pivot. For array
# 3, 4, 5, 6, 1, 2 it returns 3
# (index of 6)
def findPivot(arr, low, high):
 
    # base cases
    if high < low:
        return -1
    if high == low:
        return low
 
    # low + (high - low)/2;
    mid = int((low + high)/2)
 
    if mid < high and arr[mid] > arr[mid + 1]:
        return mid
    if mid > low and arr[mid] < arr[mid - 1]:
        return (mid-1)
    if arr[low] >= arr[mid]:
        return findPivot(arr, low, mid-1)
    return findPivot(arr, mid + 1, high)
 
# Standard Binary Search function
def binarySearch(arr, low, high, key):
 
    if high < low:
        return -1
 
    # low + (high - low)/2;
    mid = int((low + high)/2)
 
    if key == arr[mid]:
        return mid
    if key > arr[mid]:
        return binarySearch(arr, (mid + 1), high,
                            key)
    return binarySearch(arr, low, (mid - 1), key)
 
 
# Driver program to check above functions
# Let us search 3 in below array
if __name__ == '__main__':
    arr1 = [5, 6, 7, 8, 9, 10, 1, 2, 3]
    n = len(arr1)
    key = 3
    print(""Index of the element is : "", \
          pivotedBinarySearch(arr1, n, key))
 
# This is contributed by Smitha Dinesh Semwal",logn,nlogn,nlogn,0,nlogn
80,"def countRotations(arr, n):
    # Check is array is rotated
    if (arr[0] > arr[n - 1]):
 
        # Traverse the array
        for i in range(0, n):
 
            # Index where element is greater
            # than the next element
            if (arr[i] > arr[i + 1]):
                return i + 1
 
    # Array is not rotated
    return 0
 
# Driver code
arr = [15, 18, 2, 3, 6, 12]
n = len(arr)
print(countRotations(arr, n))
 
# This code is contributed by karandeep1234",linear,quadratic,quadratic,0,quadratic
81,"# Returns count of rotations for an array which
# is first sorted in ascending order, then rotated
 
# Observation: We have to return index of the smallest element
 
 
def countRotations(arr, n):
 
    low = 0
    high = n - 1
    while(low <= high):
 
        # if first element is mid or
        # last element is mid
        # then simply use modulo
        # so it never goes out of bound.
        mid = low + ((high - low) // 2)
        prev = (mid - 1 + n) % n
        next = (mid + 1) % n
 
        if(arr[mid] <= arr[prev]
           and arr[mid] <= arr[next]):
            return mid
        elif (arr[mid] <= arr[high]):
            high = mid - 1
        elif (arr[mid] >= arr[low]):
            low = mid + 1
    return 0
 
# Driver code
 
 
arr = [15, 18, 2, 3, 6, 12]
n = len(arr)
print(countRotations(arr, n))
 
# This code is contributed by shinjanpatra.",logn,n,linear,0,n
82,"# Python3 program to find
# k-th absolute difference
# between two elements
from bisect import bisect as upper_bound
 
# returns number of pairs with
# absolute difference less than
# or equal to mid.
def countPairs(a, n, mid):
    res = 0
    for i in range(n):
 
        # Upper bound returns pointer to position
        # of next higher number than a[i]+mid in
        # a[i..n-1]. We subtract (a + i + 1) from
        # this position to count
        res += upper_bound(a, a[i] + mid)
    return res
 
# Returns k-th absolute difference
def kthDiff(a, n, k):
     
    # Sort array
    a = sorted(a)
 
    # Minimum absolute difference
    low = a[1] - a[0]
    for i in range(1, n - 1):
        low = min(low, a[i + 1] - a[i])
 
    # Maximum absolute difference
    high = a[n - 1] - a[0]
 
    # Do binary search for k-th absolute difference
    while (low < high):
        mid = (low + high) >> 1
        if (countPairs(a, n, mid) < k):
            low = mid + 1
        else:
            high = mid
 
    return low
 
# Driver code
k = 3
a = [1, 2, 3, 4]
n = len(a)
print(kthDiff(a, n, k))
 
# This code is contributed by Mohit Kumar",nlogn,nlogn,nlogn,1,nlogn
83,"# Python3 program to perform range
# queries over range queries.
import math
 
max = 10000
 
# For prefix sum array
def update(arr, l):
     
    arr[l] += arr[l - 1]
 
# This function is used to apply square root
# decomposition in the record array
def record_func(block_size, block,
                record, l, r, value):
 
    # Traversing first block in range
    while (l < r and
           l % block_size != 0 and
           l != 0):
        record[l] += value
        l += 1
 
    # Traversing completely overlapped
    # blocks in range
    while (l + block_size <= r + 1):
        block[l // block_size] += value
        l += block_size
 
    # Traversing last block in range
    while (l <= r):
        record[l] += value
        l += 1
 
# Function to print the resultant array
def print_array(arr, n):
     
    for i in range(n):
        print(arr[i], end = "" "")
 
# Driver code
if __name__ == ""__main__"":
 
    n = 5
    m = 5
    arr = [0] * n
    record = [0] * m
     
    block_size = (int)(math.sqrt(m))
    block = [0] * max
     
    command = [ [ 1, 1, 2 ],
                [ 1, 4, 5 ],
                [ 2, 1, 2 ],
                [ 2, 1, 3 ],
                [ 2, 3, 4 ] ]
 
    for i in range(m - 1, -1, -1):
 
        # If query is of type 2 then function
        # call to record_func
        if (command[i][0] == 2):
            x = i // (block_size)
             
            record_func(block_size, block,
                        record, command[i][1] - 1,
                                command[i][2] - 1,
                        (block[x] + record[i] + 1))
 
        # If query is of type 1 then simply add
        # 1 to the record array
        else:
            record[i] += 1
 
    # Merging the value of the block
    # in the record array
    for i in range(m):
        check = (i // block_size)
        record[i] += block[check]
 
    for i in range(m):
         
        # If query is of type 1 then the array
        # elements are over-written by the record
        # array
        if (command[i][0] == 1):
            arr[command[i][1] - 1] += record[i]
             
            if ((command[i][2] - 1) < n - 1):
                arr[(command[i][2])] -= record[i]
 
    # The prefix sum of the array
    for i in range(1, n):
        update(arr, i)
 
    # Printing the resultant array
    print_array(arr, n)
 
# This code is contributed by chitranayal",logn,quadratic,quadratic,0,quadratic
84,"# Python3 program to find Minimum
# number of jumps to reach end
 
# Returns minimum number of jumps
# to reach arr[n-1] from arr[0]
 
 
def minJumps(arr, n):
    jumps = [0 for i in range(n)]
 
    if (n == 0) or (arr[0] == 0):
        return float('inf')
 
    jumps[0] = 0
 
    # Find the minimum number of
    # jumps to reach arr[i] from
    # arr[0] and assign this
    # value to jumps[i]
    for i in range(1, n):
        jumps[i] = float('inf')
        for j in range(i):
            if (i <= j + arr[j]) and (jumps[j] != float('inf')):
                jumps[i] = min(jumps[i], jumps[j] + 1)
                break
    return jumps[n-1]
 
 
# Driver Program to test above function
arr = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]
size = len(arr)
print('Minimum number of jumps to reach',
      'end is', minJumps(arr, size))
 
# This code is contributed by Soumen Ghosh",np,n,linear,0,n
85,"# A Simple python program to find longest common
# subarray of two binary arrays with same sum
 
# Returns length of the longest common subarray
# with same sum
def longestCommonSum(arr1, arr2, n):
 
    # Initialize result
    maxLen = 0
 
    # One by one pick all possible starting points
    # of subarrays
    for i in range(0,n):
 
        # Initialize sums of current subarrays
        sum1 = 0
        sum2 = 0
 
        # Consider all points for starting with arr[i]
        for j in range(i,n):
     
            # Update sums
            sum1 += arr1[j]
            sum2 += arr2[j]
 
            # If sums are same and current length is
            # more than maxLen, update maxLen
            if (sum1 == sum2):
                len = j-i+1
                if (len > maxLen):
                    maxLen = len
     
    return maxLen
 
 
# Driver program to test above function
arr1 = [0, 1, 0, 1, 1, 1, 1]
arr2 = [1, 1, 1, 1, 1, 0, 1]
n = len(arr1)
print(""Length of the longest common span with same ""
            ""sum is"",longestCommonSum(arr1, arr2, n))
 
# This code is contributed by
# Smitha Dinesh Semwal",quadratic,n,linear,0,n
86,"# Python 3 program to print an array
# in alternate sorted manner.
 
# Function to print alternate sorted
# values
def alternateSort(arr, n):
 
    # Sorting the array
    arr.sort()
 
    # Printing the last element of array
    # first and then first element and then
    # second last element and then second
    # element and so on.
    i = 0
    j = n-1
     
    while (i < j):
     
        print(arr[j], end ="" "")
        j-= 1
        print(arr[i], end ="" "")
        i+= 1
 
    # If the total element in array is odd
    # then print the last middle element.
    if (n % 2 != 0):
        print(arr[i])
 
 
# Driver code
arr = [1, 12, 4, 6, 7, 10]
n = len(arr)
 
alternateSort(arr, n)
 
# This code is contributed by
# Smitha Dinesh Semwal",nlogn,quadratic,quadratic,0,quadratic
87,"# Python3 program to find
# minimum number of swaps
# required to sort an array
 
# Return the minimum number
# of swaps required to sort
# the array
def minSwap(arr, n):
     
    ans = 0
    temp = arr.copy()
 
    # Dictionary which stores the
      # indexes of the input array
    h = {}
 
    temp.sort()
 
    for i in range(n):
         
        #h.[arr[i]
        h[arr[i]] = i
         
    init = 0
     
    for i in range(n):
 
        # This is checking whether
        # the current element is
        # at the right place or not
        if (arr[i] != temp[i]):
            ans += 1
            init = arr[i]
 
            # If not, swap this element
              # with the index of the
              # element which should come here
            arr[i], arr[h[temp[i]]] = arr[h[temp[i]]], arr[i]
 
            # Update the indexes in
              # the hashmap accordingly
            h[init] = h[temp[i]]
            h[temp[i]] = i
             
    return ans
 
# Driver code
a = [ 101, 758, 315, 730,
      472, 619, 460, 479 ]
n = len(a)
 
# Output will be 5
print(minSwap(a, n))
 
# This code is contributed by avanitrachhadiya2155",nlogn,n,linear,0,n
88,"# Python program to merge
# two sorted arrays
# with O(1) extra space.
 
# Merge ar1[] and ar2[]
# with O(1) extra space
 
 
def rotate(a, n, idx):
    for i in range((int)(idx/2)):
        a[i], a[idx-1-i] = a[idx-1-i], a[i]
    for i in range(idx, (int)((n+idx)/2)):
        a[i], a[n-1-(i-idx)] = a[n-1-(i-idx)], a[i]
    for i in range((int)(n/2)):
        a[i], a[n-1-i] = a[n-1-i], a[i]
 
 
def sol(a1, a2, n, m):
    l = 0
    h = n-1
    idx = 0
    while (l <= h):
        c1 = (int)((l+h)/2)
        c2 = n-c1-1
        l1 = a1[c1]
        l2 = a2[c2-1]
        r1 = sys.maxint if c1 == n-1 else a1[c1+1]
        r2 = sys.maxint if c2 == m else a2[c2]
        if l1 > r2:
            h = c1-1
            if h == -1:
                idx = 0
        elif l2 > r1:
            l = c1+1
            if l == n-1:
                idx = n
        else:
            idx = c1+1
            break
    for i in range(idx, n):
        a1[i], a2[i-idx] = a2[i-idx], a1[i]
 
    a1.sort()
    a2.sort()
 
 
def merge(a1, a2, n, m):
    if n > m:
        sol(a2, a1, m, n)
        rotate(a1, n, n-m)
        for i in range(m):
            a1[i], a2[i] = a2[i], a1[i]
    else:
        sol(a1, a2, n, m)
# Driver program
 
 
ar1 = [1, 5, 9, 10, 15, 20]
ar2 = [2, 3, 8, 13]
m = len(ar1)
n = len(ar2)
 
merge(ar1, ar2, m, n)
 
print(""After Merging \nFirst Array:"", end="""")
for i in range(m):
    print(ar1[i], "" "", end="""")
print(""\nSecond Array: "", end="""")
for i in range(n):
    print(ar2[i], "" "", end="""")
# This code is contributed
# by Aditya Anand.",nlogn,quadratic,quadratic,0,quadratic
89,"# python 3  program to implement
# binary search in sorted array
 
 
def binarySearch(arr, low, high, key):
 
    mid = (low + high)/2
 
    if (key == arr[int(mid)]):
        return mid
 
    if (key > arr[int(mid)]):
        return binarySearch(arr,
                            (mid + 1), high, key)
 
    if (key < arr[int(mid)]):
        return binarySearch(arr, low, (mid-1), key)
 
    return 0
 
 
# Driver code
if __name__ == ""__main__"":
    # Let us search 3 in below array
    arr = [5, 6, 7, 8, 9, 10]
    n = len(arr)
    key = 10
 
    # Function call
    print(""Index:"", int(binarySearch(arr, 0, n-1, key)))
 
# This code is contributed by
# Smitha Dinesh Semwal",logn,n,linear,0,n
90,"# A python3 program to find a peak
#  element using divide and conquer
 
# A binary search based function
# that returns index of a peak element
 
 
def findPeakUtil(arr, low, high, n):
 
    # Find index of middle element
    # low + (high - low) / 2
    mid = low + (high - low)/2
    mid = int(mid)
 
    # Compare middle element with its
    # neighbours (if neighbours exist)
    if ((mid == 0 or arr[mid - 1] <= arr[mid]) and
        (mid == n - 1 or arr[mid + 1] <= arr[mid])):
        return mid
 
 
    # If middle element is not peak and
    # its left neighbour is greater
    # than it, then left half must
    # have a peak element
    elif (mid > 0 and arr[mid - 1] > arr[mid]):
        return findPeakUtil(arr, low, (mid - 1), n)
 
    # If middle element is not peak and
    # its right neighbour is greater
    # than it, then right half must
    # have a peak element
    else:
        return findPeakUtil(arr, (mid + 1), high, n)
 
 
# A wrapper over recursive
# function findPeakUtil()
def findPeak(arr, n):
 
    return findPeakUtil(arr, 0, n - 1, n)
 
 
# Driver code
arr = [1, 3, 20, 4, 1, 0]
n = len(arr)
print(""Index of a peak point is"", findPeak(arr, n))
     
# This code is contributed by
# Smitha Dinesh Semwal",logn,n,linear,0,n
91,"# A simple Python 3 program
# to find three elements whose
# sum is equal to zero
 
# Prints all triplets in
# arr[] with 0 sum
 
 
def findTriplets(arr, n):
 
    found = False
    for i in range(0, n-2):
 
        for j in range(i+1, n-1):
 
            for k in range(j+1, n):
 
                if (arr[i] + arr[j] + arr[k] == 0):
                    print(arr[i], arr[j], arr[k])
                    found = True
 
    # If no triplet with 0 sum
    # found in array
    if (found == False):
        print("" not exist "")
 
 
# Driver code
arr = [0, -1, 2, -3, 1]
n = len(arr)
findTriplets(arr, n)
 
# This code is contributed by Smitha Dinesh Semwal",cubic,quadratic,quadratic,0,quadratic
92,"# Python3 program to check if all rows
# of a matrix are rotations of each other
 
MAX = 1000
 
# Returns true if all rows of mat[0..n-1][0..n-1]
# are rotations of each other.
def isPermutedMatrix(mat, n) :
     
    # Creating a string that contains
    # elements of first row.
    str_cat = """"
    for i in range(n) :
        str_cat = str_cat + ""-"" + str(mat[0][i])
 
    # Concatenating the string with itself
    # so that substring search operations
    # can be performed on this
    str_cat = str_cat + str_cat
 
    # Start traversing remaining rows
    for i in range(1, n) :
         
        # Store the matrix into vector
        # in the form of strings
        curr_str = """"
         
        for j in range(n) :
            curr_str = curr_str + ""-"" + str(mat[i][j])
 
        # Check if the current string is present
        # in the concatenated string or not
        if (str_cat.find(curr_str)) :
            return True
             
    return False
 
# Driver code
if __name__ == ""__main__"" :
    n = 4
    mat = [[1, 2, 3, 4],
           [4, 1, 2, 3],
           [3, 4, 1, 2],
           [2, 3, 4, 1]]
     
    if (isPermutedMatrix(mat, n)):
        print(""Yes"")
    else :
        print(""No"")
         
# This code is contributed by Ryuga",cubic,quadratic,quadratic,0,quadratic
93,"# Python program for an efficient solution to check if
# a given array can represent Preorder traversal of
# a Binary Search Tree
 
INT_MIN = -2**32
 
def canRepresentBST(pre):
 
    # Create an empty stack
    s = []
 
    # Initialize current root as minimum possible value
    root = INT_MIN
 
    # Traverse given array
    for value in pre:
        #NOTE:value is equal to pre[i] according to the
        #given algo  
     
        # If we find a node who is on the right side
        # and smaller than root, return False
        if value < root :
            return False
     
        # If value(pre[i]) is in right subtree of stack top,
        # Keep removing items smaller than value
        # and make the last removed items as new root
        while(len(s) > 0 and s[-1] < value) :
            root = s.pop()
         
        # At this point either stack is empty or value
        # is smaller than root, push value
        s.append(value)
 
    return True
 
# Driver Program
pre1 = [40 , 30 , 35 , 80 , 100]
print (""true"" if canRepresentBST(pre1) == True else ""false"")
pre2 = [40 , 30 , 35 , 20 ,  80 , 100]
print (""true"" if canRepresentBST(pre2) == True else ""false"")
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)",linear,nlogn,nlogn,0,nlogn
94,"# A recursive python program to find LCA of two nodes
# n1 and n2
 
# A Binary tree node
 
 
class Node:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# Function to find LCA of n1 and n2. The function assumes
# that both n1 and n2 are present in BST
 
 
def lca(root, n1, n2):
 
    # Base Case
    if root is None:
        return None
 
    # If both n1 and n2 are smaller than root, then LCA
    # lies in left
    if(root.data > n1 and root.data > n2):
        return lca(root.left, n1, n2)
 
    # If both n1 and n2 are greater than root, then LCA
    # lies in right
    if(root.data < n1 and root.data < n2):
        return lca(root.right, n1, n2)
 
    return root
 
# Driver program to test above function
 
 
# Driver code
root = Node(20)
root.left = Node(8)
root.right = Node(22)
root.left.left = Node(4)
root.left.right = Node(12)
root.left.right.left = Node(10)
root.left.right.right = Node(14)
 
 
# Function calls
n1 = 10
n2 = 14
t = lca(root, n1, n2)
print(""LCA of %d and %d is %d"" % (n1, n2, t.data))
 
n1 = 14
n2 = 8
t = lca(root, n1, n2)
print(""LCA of %d and %d is %d"" % (n1, n2, t.data))
 
n1 = 10
n2 = 22
t = lca(root, n1, n2)
print(""LCA of %d and %d is %d"" % (n1, n2, t.data))
 
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)",constant,nlogn,nlogn,0,nlogn
95,"# A recursive python program to find LCA of two nodes
# n1 and n2
 
# A Binary tree node
 
 
class Node:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# Function to find LCA of n1 and n2.
# The function assumes that both
#   n1 and n2 are present in BST
 
 
def lca(root, n1, n2):
    while root:
        # If both n1 and n2 are smaller than root,
        # then LCA lies in left
        if root.data > n1 and root.data > n2:
            root = root.left
 
        # If both n1 and n2 are greater than root,
        # then LCA lies in right
        elif root.data < n1 and root.data < n2:
            root = root.right
 
        else:
            break
 
    return root
 
 
# Driver code
if __name__ == '__main__':
  root = Node(20)
  root.left = Node(8)
  root.right = Node(22)
  root.left.left = Node(4)
  root.left.right = Node(12)
  root.left.right.left = Node(10)
  root.left.right.right = Node(14)
 
  # Function calls
  n1 = 10
  n2 = 14
  t = lca(root, n1, n2)
  print(""LCA of %d and %d is %d"" % (n1, n2, t.data))
 
  n1 = 14
  n2 = 8
  t = lca(root, n1, n2)
  print(""LCA of %d and %d is %d"" % (n1, n2, t.data))
 
  n1 = 10
  n2 = 22
  t = lca(root, n1, n2)
  print(""LCA of %d and %d is %d"" % (n1, n2, t.data))
# This Code is Contributed by Sumit Bhardwaj (Timus)",constant,nlogn,nlogn,0,nlogn
96,"# Python3 program to count BST nodes
# within a given range
 
# Utility function to create new node
class newNode:
 
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
 
# Returns count of nodes in BST in
# range [low, high]
def getCount(root, low, high):
     
    # Base case
    if root == None:
        return 0
         
    # Special Optional case for improving
    # efficiency
    if root.data == high and root.data == low:
        return 1
 
    # If current node is in range, then
    # include it in count and recur for
    # left and right children of it
    if root.data <= high and root.data >= low:
        return (1 + getCount(root.left, low, high) +
                    getCount(root.right, low, high))
 
    # If current node is smaller than low,
    # then recur for right child
    elif root.data < low:
        return getCount(root.right, low, high)
 
    # Else recur for left child
    else:
        return getCount(root.left, low, high)
 
# Driver Code
if __name__ == '__main__':
     
    # Let us construct the BST shown in
    # the above figure
    root = newNode(10)
    root.left = newNode(5)
    root.right = newNode(50)
    root.left.left = newNode(1)
    root.right.left = newNode(40)
    root.right.right = newNode(100)
     
    # Let us constructed BST shown in above example
    #     10
    #     / \
    # 5     50
    # /     / \
    # 1     40 100
    l = 5
    h = 45
    print(""Count of nodes between ["", l, "", "", h,""] is "",
                                    getCount(root, l, h))
 
# This code is contributed by PranchalK",constant,nlogn,nlogn,0,nlogn
97,"# Python3 implementation of tree using array
# numbering starting from 0 to n-1.
tree = [None] * 10
 
 
def root(key):
    if tree[0] != None:
        print(""Tree already had root"")
    else:
        tree[0] = key
 
 
def set_left(key, parent):
    if tree[parent] == None:
        print(""Can't set child at"", (parent * 2) + 1, "", no parent found"")
    else:
        tree[(parent * 2) + 1] = key
 
 
def set_right(key, parent):
    if tree[parent] == None:
        print(""Can't set child at"", (parent * 2) + 2, "", no parent found"")
    else:
        tree[(parent * 2) + 2] = key
 
 
def print_tree():
    for i in range(10):
        if tree[i] != None:
            print(tree[i], end="""")
        else:
            print(""-"", end="""")
    print()
 
 
# Driver Code
root('A')
set_right('C', 0)
set_left('D', 1)
set_right('E', 1)
set_right('F', 2)
print_tree()
 
# This code is contributed by Gaurav Kumar Tailor",logn,quadratic,quadratic,0,quadratic
98,"# Python program to construct tree using
# inorder and level order traversals
 
# A binary tree node
 
 
class Node:
 
    # Constructor to create a new node
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None
 
 
""""""Recursive function to construct binary tree of size n from
Inorder traversal ino[] and Level Order traversal level[].
The function doesn't do any error checking for cases
where inorder and levelorder do not form a tree """"""
 
 
def buildTree(level, ino):
 
    # If ino array is not empty
    if ino:
 
        # Check if that element exist in level order
        for i in range(0, len(level)):
 
            if level[i] in ino:
 
                # Create a new node with
                # the matched element
                node = Node(level[i])
 
                # Get the index of the matched element
                # in level order array
                io_index = ino.index(level[i])
                break
 
        # Construct left and right subtree
        node.left = buildTree(level, ino[0:io_index])
        node.right = buildTree(level, ino[io_index + 1:len(ino)])
        return node
 
    else:
        return None
 
 
def printInorder(node):
    if node is None:
        return
 
    # first recur on left child
    printInorder(node.left)
 
    # then print the data of node
    print(node.data, end="" "")
 
    # now recur on right child
    printInorder(node.right)
 
# Driver code
 
 
levelorder = [20, 8, 22, 4, 12, 10, 14]
inorder = [4, 8, 10, 12, 14, 20, 22]
 
ino_len = len(inorder)
root = buildTree(levelorder, inorder)
 
# Let us test the build tree by
# printing Inorder traversal
print(""Inorder traversal of the constructed tree is"")
printInorder(root)
 
# This code is contributed by 'Vaibhav Kumar'",cubic,quadratic,quadratic,0,quadratic
99,"# Python3 program to check if all leaf nodes
# are at same level of binary tree
INT_MAX = 2**31
INT_MIN = -2**31
 
# Tree Node
# returns a new tree Node
class newNode:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None
         
# return true if all leaf nodes are
# at same level, else false
def checkLevelLeafNode(root) :
 
    if (not root) :
        return 1
     
    # create a queue for level
    # order traversal
    q = []
    q.append(root)
     
    result = INT_MAX
    level = 0
 
    # traverse until the queue is empty
    while (len(q)):
        size = len(q)
        level += 1
 
        # traverse for complete level
        while(size > 0 or len(q)):
            temp = q[0]
            q.pop(0)
         
            # check for left child
            if (temp.left) :
                q.append(temp.left)
 
                # if its leaf node
                if(not temp.left.right and
                   not temp.left.left):
 
                    # if it's first leaf node,
                    # then update result
                    if (result == INT_MAX):
                        result = level
                     
                    # if it's not first leaf node,
                    # then compare the level with
                    # level of previous leaf node
                    elif (result != level):
                        return 0                   
                 
            # check for right child
            if (temp.right) :
                q.append(temp.right)
 
                # if it's leaf node
                if (not temp.right.left and
                    not temp.right.right):
 
                    # if it's first leaf node till now,
                    # then update the result
                    if (result == INT_MAX):
                        result = level
                     
                    # if it is not the first leaf node,
                    # then compare the level with level
                    # of previous leaf node
                    elif(result != level):
                        return 0
                size -= 1
    return 1
 
# Driver Code
if __name__ == '__main__':
     
    # construct a tree
    root = newNode(1)
    root.left = newNode(2)
    root.right = newNode(3)
    root.left.right = newNode(4)
    root.right.left = newNode(5)
    root.right.right = newNode(6)
     
    result = checkLevelLeafNode(root)
    if (result) :
        print(""All leaf nodes are at same level"")
    else:
        print(""Leaf nodes not at same level"")
 
# This code is contributed by SHUBHAMSINGH10",linear,nlogn,nlogn,0,nlogn
100,"# Python3 program to program to check if a
# given Binary Tree is symmetric or not
 
# Helper function that allocates a new
# node with the given data and None
# left and right pairs.                                    
class newNode:
 
    # Constructor to create a new node
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
 
# function to check if a given
# Binary Tree is symmetric or not
def isSymmetric( root) :
 
    # if tree is empty
    if (root == None) :
        return True
     
    # If it is a single tree node,
    # then it is a symmetric tree.
    if(not root.left and not root.right):
        return True
     
    q = []    
     
    # Add root to queue two times so that
    # it can be checked if either one
    # child alone is NULL or not.
    q.append(root)
    q.append(root)
     
    # To store two nodes for checking
    # their symmetry.
    leftNode = 0
    rightNode = 0
     
    while(not len(q)):
         
        # Remove first two nodes to
        # check their symmetry.
        leftNode = q[0]
        q.pop(0)
         
        rightNode = q[0]
        q.pop(0)
         
        # if both left and right nodes
        # exist, but have different
        # values-. inequality, return False
        if(leftNode.key != rightNode.key):
            return False
         
        # append left child of left subtree
        # node and right child of right 
        # subtree node in queue.
        if(leftNode.left and rightNode.right) :
            q.append(leftNode.left)
            q.append(rightNode.right)
         
        # If only one child is present
        # alone and other is NULL, then
        # tree is not symmetric.
        elif (leftNode.left or rightNode.right) :
            return False
         
        # append right child of left subtree
        # node and left child of right subtree
        # node in queue.
        if(leftNode.right and rightNode.left):
            q.append(leftNode.right)
            q.append(rightNode.left)
         
        # If only one child is present
        # alone and other is NULL, then
        # tree is not symmetric.
        elif(leftNode.right or rightNode.left):
            return False
     
    return True
         
# Driver Code
if __name__ == '__main__':
     
    # Let us construct the Tree
    # shown in the above figure
    root = newNode(1)
    root.left = newNode(2)
    root.right = newNode(2)
    root.left.left = newNode(3)
    root.left.right = newNode(4)
    root.right.left = newNode(4)
    root.right.right = newNode(3)
    if (isSymmetric(root)) :
        print(""The given tree is Symmetric"")
    else:
        print(""The given tree is not Symmetric"")
 
# This code is contributed by
# Shubham Singh(SHUBHAMSINGH10)",linear,n,linear,1,n
101,"# Python 3 program to count all paths
# from a source to a destination.
 
# A directed graph using adjacency
# list representation
 
 
class Graph:
 
    def __init__(self, V):
        self.V = V
        self.adj = [[] for i in range(V)]
 
    def addEdge(self, u, v):
 
        # Add v to us list.
        self.adj[u].append(v)
 
    # Returns count of paths from 's' to 'd'
    def countPaths(self, s, d):
 
        # Mark all the vertices
        # as not visited
        visited = [False] * self.V
 
        # Call the recursive helper
        # function to print all paths
        pathCount = [0]
        self.countPathsUtil(s, d, visited, pathCount)
        return pathCount[0]
 
    # A recursive function to print all paths
    # from 'u' to 'd'. visited[] keeps track
    # of vertices in current path. path[]
    # stores actual vertices and path_index
    # is current index in path[]
    def countPathsUtil(self, u, d,
                       visited, pathCount):
        visited[u] = True
 
        # If current vertex is same as
        # destination, then increment count
        if (u == d):
            pathCount[0] += 1
 
        # If current vertex is not destination
        else:
 
            # Recur for all the vertices
            # adjacent to current vertex
            i = 0
            while i < len(self.adj[u]):
                if (not visited[self.adj[u][i]]):
                    self.countPathsUtil(self.adj[u][i], d,
                                        visited, pathCount)
                i += 1
 
        visited[u] = False
 
 
# Driver Code
if __name__ == '__main__':
 
    # Create a graph given in the
    # above diagram
    g = Graph(4)
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(0, 3)
    g.addEdge(2, 0)
    g.addEdge(2, 1)
    g.addEdge(1, 3)
 
    s = 2
    d = 3
     
    # Function call
    print(g.countPaths(s, d))
 
# This code is contributed by PranchalK",np,quadratic,quadratic,0,quadratic
102,"# Python3 program to implement Union-Find
# with union by rank and path compression.
 
# set parent of every node to itself
# and size of node to one
def initialize(n):
    global Arr, size
    for i in range(n + 1):
        Arr[i] = i
        size[i] = 1
 
# Each time we follow a path, find
# function compresses it further
# until the path length is greater
# than or equal to 1.
def find(i):
    global Arr, size
     
    # while we reach a node whose
    # parent is equal to itself
    while (Arr[i] != i):
        Arr[i] = Arr[Arr[i]] # Skip one level
        i = Arr[i] # Move to the new level
    return i
 
# A function that does union of two
# nodes x and y where xr is root node
# of x and yr is root node of y
def _union(xr, yr):
    global Arr, size
    if (size[xr] < size[yr]): # Make yr parent of xr
        Arr[xr] = Arr[yr]
        size[yr] += size[xr]
    else: # Make xr parent of yr
        Arr[yr] = Arr[xr]
        size[xr] += size[yr]
 
# The main function to check whether
# a given graph contains cycle or not
def isCycle(adj, V):
    global Arr, size
     
    # Iterate through all edges of graph,
    # find nodes connecting them.
    # If root nodes of both are same,
    # then there is cycle in graph.
    for i in range(V):
        for j in range(len(adj[i])):
            x = find(i) # find root of i
            y = find(adj[i][j]) # find root of adj[i][j]
 
            if (x == y):
                return 1 # If same parent
            _union(x, y) # Make them connect
    return 0
 
# Driver Code
MAX_VERTEX = 101
 
# Arr to represent parent of index i
Arr = [None] * MAX_VERTEX
 
# Size to represent the number of nodes
# in subgraph rooted at index i
size = [None] * MAX_VERTEX
 
V = 3
 
# Initialize the values for array
# Arr and Size
initialize(V)
 
# Let us create following graph
#     0
# | \
# | \
# 1-----2
 
# Adjacency list for graph
adj = [[] for i in range(V)]
 
adj[0].append(1)
adj[0].append(2)
adj[1].append(2)
 
# call is_cycle to check if it
# contains cycle
if (isCycle(adj, V)):
    print(""Graph contains Cycle."")
else:
    print(""Graph does not contain Cycle."")
 
# This code is contributed by PranchalK",logn,n,linear,0,n
103,"# Python3 program to solve N Queen 
# Problem using backtracking
global N
N = 4
  
def printSolution(board): 
    for i in range(N):
        for j in range(N):
            print(board[i][j], end = "" "")
        print() 
  
# A utility function to check if a queen can
# be placed on board[row][col]. Note that this
# function is called when ""col"" queens are
# already placed in columns from 0 to col -1.
# So we need to check only left side for
# attacking queens
def isSafe(board, row, col):
  
    # Check this row on left side
    for i in range(col):
        if board[row][i] == 1:
            return False
  
    # Check upper diagonal on left side
    for i, j in zip(range(row, -1, -1), 
                    range(col, -1, -1)):
        if board[i][j] == 1:
            return False
  
    # Check lower diagonal on left side
    for i, j in zip(range(row, N, 1), 
                    range(col, -1, -1)):
        if board[i][j] == 1:
            return False
  
    return True
  
def solveNQUtil(board, col):
      
    # base case: If all queens are placed
    # then return true
    if col >= N:
        return True
  
    # Consider this column and try placing
    # this queen in all rows one by one
    for i in range(N):
  
        if isSafe(board, i, col):
              
            # Place this queen in board[i][col]
            board[i][col] = 1
  
            # recur to place rest of the queens
            if solveNQUtil(board, col + 1) == True:
                return True
  
            # If placing queen in board[i][col
            # doesn't lead to a solution, then
            # queen from board[i][col]
            board[i][col] = 0
  
    # if the queen can not be placed in any row in
    # this column col then return false
    return False
  
# This function solves the N Queen problem using
# Backtracking. It mainly uses solveNQUtil() to
# solve the problem. It returns false if queens
# cannot be placed, otherwise return true and
# placement of queens in the form of 1s.
# note that there may be more than one
# solutions, this function prints one of the
# feasible solutions.
def solveNQ():
    board = [ [0, 0, 0, 0],
              [0, 0, 0, 0],
              [0, 0, 0, 0],
              [0, 0, 0, 0] ]
  
    if solveNQUtil(board, 0) == False:
        print (""Solution does not exist"")
        return False
  
    printSolution(board)
    return True
  
# Driver Code
solveNQ()
  
# This code is contributed by Divyanshu Mehta",np,nlogn,nlogn,0,nlogn
104,"# Python program to check for the sum
# condition to be satisfied
 
 
def hasArrayTwoCandidates(A, arr_size, sum):
 
    # sort the array
    quickSort(A, 0, arr_size-1)
    l = 0
    r = arr_size-1
 
    # traverse the array for the two elements
    while l < r:
        if (A[l] + A[r] == sum):
            return 1
        elif (A[l] + A[r] < sum):
            l += 1
        else:
            r -= 1
    return 0
 
# Implementation of Quick Sort
# A[] --> Array to be sorted
# si  --> Starting index
# ei  --> Ending index
 
 
def quickSort(A, si, ei):
    if si < ei:
        pi = partition(A, si, ei)
        quickSort(A, si, pi-1)
        quickSort(A, pi + 1, ei)
 
# Utility function for partitioning
# the array(used in quick sort)
 
 
def partition(A, si, ei):
    x = A[ei]
    i = (si-1)
    for j in range(si, ei):
        if A[j] <= x:
            i += 1
 
            # This operation is used to swap
            # two variables is python
            A[i], A[j] = A[j], A[i]
 
        A[i + 1], A[ei] = A[ei], A[i + 1]
 
    return i + 1
 
 
# Driver program to test the functions
A = [1, 4, 45, 6, 10, -8]
n = 16
if (hasArrayTwoCandidates(A, len(A), n)):
    print(""Yes"")
else:
    print(""No"")
 
# This code is contributed by __Devesh Agrawal__",nlogn,quadratic,quadratic,0,quadratic
105,"# Python3 program to find the only
# repeating element in an array where
# elements are from 1 to N-1.
 
 
def findRepeating(arr, N):
    arr.sort()
    for i in range(1, N):
        if(arr[i] != i+1):
            return arr[i]
 
 
# Driver's Code
if __name__ == ""__main__"":
  arr = [9, 8, 2, 6, 1, 8, 5, 3, 4, 7]
  N = len(arr)
 
  # Function call
  print(findRepeating(arr, N))
 
# This code is contributed by Arpit Jain",nlogn,quadratic,quadratic,0,quadratic
106,"# Python 3 program to find a pair with
# given sum such that every element of
# pair is in different rows.
MAX = 100
 
# Function to find pair for given
# sum in matrix mat[][] --> given matrix
# n --> order of matrix
# sum --> given sum for which we
# need to find pair
def pairSum(mat, n, sum):
 
    # First sort all the rows
    # in ascending order
    for i in range(n):
        mat[i].sort()
 
    # Select i'th row and find pair for
    # element in i'th row in j'th row
    # whose summation is equal to given sum
    for i in range(n - 1):
        for j in range(i + 1, n):
            left = 0
            right = n - 1
            while (left < n and right >= 0):
                if ((mat[i][left] + mat[j][right]) == sum):
                    print( ""("", mat[i][left],
                           "", "", mat[j][right], ""), "",
                                            end = "" "")
                    left += 1
                    right -= 1
                 
                else:
                    if ((mat[i][left] +
                         mat[j][right]) < sum):
                        left += 1
                    else:
                        right -= 1
 
# Driver Code
if __name__ == ""__main__"":
    n = 4
    sum = 11
    mat = [[1, 3, 2, 4],
           [5, 8, 7, 6],
           [9, 10, 13, 11],
           [12, 0, 14, 15]]
    pairSum(mat, n, sum)
 
# This code is contributed
# by ChitraNayal",cubic,quadratic,quadratic,0,quadratic
107,"# Python3 program to find
# three element from different
# three arrays such that
# a + b + c is equal to
# given sum
 
# Function to check if there
# is an element from each
# array such that sum of the
# three elements is equal to
# given sum.
def findTriplet(a1, a2, a3,
                n1, n2, n3, sum):
 
    for i in range(0 , n1):
        for j in range(0 , n2):
            for k in range(0 , n3):
                if (a1[i] + a2[j] +
                    a3[k] == sum):
                    return True
 
    return False
 
# Driver Code
a1 = [ 1 , 2 , 3 , 4 , 5 ]
a2 = [ 2 , 3 , 6 , 1 , 2 ]
a3 = [ 3 , 2 , 4 , 5 , 6 ]
sum = 9
n1 = len(a1)
n2 = len(a2)
n3 = len(a3)
print(""Yes"") if findTriplet(a1, a2, a3,
                            n1, n2, n3,
                            sum) else print(""No"")
 
# This code is contributed
# by Smitha",cubic,quadratic,quadratic,0,quadratic
108,"# python 3 program to print all triplets in given
# array that form Arithmetic Progression
  
# Function to print all triplets in
# given sorted array that forms AP
def printAllAPTriplets(arr, n):
  
    for i in range(1, n - 1):
  
        # Search other two elements of
        # AP with arr[i] as middle.
        j = i - 1
        k = i + 1
        while(j >= 0 and k < n ):
  
            # if a triplet is found
            if (arr[j] + arr[k] == 2 * arr[i]):
                print(arr[j], """", arr[i], """", arr[k])
  
                # Since elements are distinct,
                # arr[k] and arr[j] cannot form
                # any more triplets with arr[i]
                k += 1
                j -= 1
              
  
            # If middle element is more move to
            # higher side, else move lower side.
            elif (arr[j] + arr[k] < 2 * arr[i]):
                k += 1    
            else:
                j -= 1    
          
# Driver code
arr = [ 2, 6, 9, 12, 17,
        22, 31, 32, 35, 42 ]
n = len(arr)
printAllAPTriplets(arr, n)
  
# This article is contributed
# by Smitha Dinesh Semwal",quadratic,quadratic,quadratic,1,quadratic
109,"# Python3 program to count
# triplets with given product m
 
# Method to count such triplets
def countTriplets(arr, n, m):
     
    count = 0
 
    # Consider all triplets and count if
    # their product is equal to m
    for i in range (n - 2):
        for j in range (i + 1, n - 1):
            for k in range (j + 1, n):
                if (arr[i] * arr[j] * arr[k] == m):
                    count += 1
    return count
 
# Driver code
if __name__ == ""__main__"":
   
    arr = [1, 4, 6, 2, 3, 8]
    m = 24
    print(countTriplets(arr,
                        len(arr), m))
 
# This code is contributed by Chitranayal",cubic,nlogn,nlogn,0,nlogn
110,"# Python3 code to move the last item to front
 
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
 
 
class LinkedList:
    def __init__(self):
        self.head = None
 
    # Function to add a node
    # at the beginning of Linked List
    def push(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
 
    # Function to print nodes in a
    # given linked list
    def printList(self):
        tmp = self.head
        while tmp is not None:
            print(tmp.data, end="", "")
            tmp = tmp.next
        print()
 
    # Function to bring the last node to the front
    def moveToFront(self):
        tmp = self.head
        sec_last = None  # To maintain the track of
        # the second last node
 
    # To check whether we have not received
    # the empty list or list with a single node
        if not tmp or not tmp.next:
            return
 
        # Iterate till the end to get
        # the last and second last node
        while tmp and tmp.next:
            sec_last = tmp
            tmp = tmp.next
 
        # point the next of the second
        # last node to None
        sec_last.next = None
 
        # Make the last node as the first Node
        tmp.next = self.head
        self.head = tmp
 
 
# Driver's Code
if __name__ == '__main__':
    llist = LinkedList()
 
    # swap the 2 nodes
    llist.push(5)
    llist.push(4)
    llist.push(3)
    llist.push(2)
    llist.push(1)
    print(""Linked List before moving last to front "")
    llist.printList()
     
    # Function call
    llist.moveToFront()
    print(""Linked List after moving last to front "")
    llist.printList()",linear,quadratic,quadratic,0,quadratic
111,"# Python3 implementation to count triplets
# in a sorted doubly linked list
# whose sum is equal to a given value 'x'
  
# structure of node of doubly linked list
class Node: 
    def __init__(self):
        self.data = None
        self.prev = None
        self.next = None
  
# function to count triplets in a sorted doubly linked list
# whose sum is equal to a given value 'x'
def countTriplets( head, x):
  
    ptr1 = head
    ptr2 = None
    ptr3 = None
    count = 0
  
    # generate all possible triplets
    while (ptr1 != None ):
        ptr2 = ptr1.next
        while ( ptr2 != None ):
            ptr3 = ptr2.next
            while ( ptr3 != None ):
          
                # if elements in the current triplet sum up to 'x'
                if ((ptr1.data + ptr2.data + ptr3.data) == x):
  
                    # increment count
                    count = count + 1
                ptr3 = ptr3.next
            ptr2 = ptr2.next
        ptr1 = ptr1.next
  
    # required count of triplets
    return count
  
# A utility function to insert a new node at the
# beginning of doubly linked list
def insert(head, data):
  
    # allocate node
    temp = Node()
  
    # put in the data
    temp.data = data
    temp.next = temp.prev = None
  
    if ((head) == None):
        (head) = temp
    else :
        temp.next = head
        (head).prev = temp
        (head) = temp
    return head
      
# Driver code
  
# start with an empty doubly linked list
head = None
  
# insert values in sorted order
head = insert(head, 9)
head = insert(head, 8)
head = insert(head, 6)
head = insert(head, 5)
head = insert(head, 4)
head = insert(head, 2)
head = insert(head, 1)
  
x = 17
  
print( ""Count = "", countTriplets(head, x))
  
# This code is contributed by Arnab Kundu",cubic,nlogn,nlogn,0,nlogn
112,"# Python implementation to sort a k sorted doubly linked list
import heapq
head = None
 
#  a node of the doubly linked list
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
 
# function to sort a k sorted doubly linked list
def sortAKSortedDLL(head, k):
    # if list is empty
    if head == None:
        return head
 
    pq = []
 
    newHead = None
    last = None
 
    for i in range(k+1):
        # push the node
        heapq.heappush(pq, (head.data, head))
        # move to the next node
        head = head.next
 
    # loop till there are elements in 'pq'
    while len(pq) > 0:
 
        if newHead == None:
            newHead = heapq.heappop(pq)[1]
            newHead.prev = None
 
        #  'last' points to the last node of the result sorted list so far
            last = newHead
        else:
            last.next = heapq.heappop(pq)[1]
            last.next.prev = last
            last = last.next
 
        # if there are more nodes left in the input list
        if head != None:
            # push the node
            heapq.heappush(pq, (head.data, head))
 
            # move to the next node
            head = head.next
 
    # making 'next' of last node point to NULL
    last.next = None
 
    # new head of the required sorted DLL
    return newHead
 
# Function to insert a node at the beginning of the Doubly Linked List
def push(new_data):
 
    global head
 
    # allocate node
    new_node = Node(new_data)
 
    # since we are adding at the beginning, prev is always NULL
    new_node.prev = None
 
    # link the old list off the new node
    new_node.next = head
 
    # change prev of head node to new node
    if (head != None):
        head.prev = new_node
 
    # move the head to point to the new node
    head = new_node
 
 
# Function to print nodes in a given doubly linked list
def printList(head):
    # if list is empty
    if head is None:
        print(""Doubly Linked list empty"")
 
    while head is not None:
        print(head.data, end="" "")
        head = head.next
 
 
# Driver code
if __name__ == '__main__':
 
    # Create the doubly linked list:
    # 3<->6<->2<->12<->56<->8
    push(8)
    push(56)
    push(12)
    push(2)
    push(6)
    push(3)
 
    k = 2
 
    print(""Original Doubly linked list:"")
    printList(head)
 
    sortedDLL = sortAKSortedDLL(head, k)
 
    print(""\nDoubly Linked List after sorting:"")
    printList(sortedDLL)
 
# This code is contributed by Tapesh(tapeshdua420)",nlogn,quadratic,quadratic,0,quadratic
113,"# Program to implement involutory matrix.
N = 3;
 
# Function for matrix multiplication.
def multiply(mat, res):
 
    for i in range(N):
        for j in range(N):
            res[i][j] = 0;
            for k in range(N):
                res[i][j] += mat[i][k] * mat[k][j];
    return res;
 
# Function to check involutory matrix.
def InvolutoryMatrix(mat):
 
    res=[[0 for i in range(N)]
            for j in range(N)];
 
    # multiply function call.
    res = multiply(mat, res);
 
    for i in range(N):
        for j in range(N):
            if (i == j and res[i][j] != 1):
                return False;
            if (i != j and res[i][j] != 0):
                return False;
    return True;
 
# Driver Code
mat = [[1, 0, 0], [0, -1, 0], [0, 0, -1]];
 
# Function call. If function
# return true then if part
# will execute otherwise
# else part will execute.
if (InvolutoryMatrix(mat)):
    print(""Involutory Matrix"");
else:
    print(""Not Involutory Matrix"");
 
# This code is contributed by mits",cubic,quadratic,quadratic,0,quadratic
114,"# Efficient Python3 program to find mirror of
# matrix across diagonal.
from builtins import range
MAX = 100;
 
def imageSwap(mat, n):
 
    # traverse a matrix and swap
    # mat[i][j] with mat[j][i]
    for i in range(n):
        for j in range(i + 1):
            t = mat[i][j];
            mat[i][j] = mat[j][i]
            mat[j][i] = t
 
# Utility function to print a matrix
def printMatrix(mat, n):
    for i in range(n):
        for j in range(n):
            print(mat[i][j], end="" "");
        print();
 
# Driver code
if __name__ == '__main__':
    mat = [1, 2, 3, 4], \
        [5, 6, 7, 8], \
        [9, 10, 11, 12], \
        [13, 14, 15, 16];
    n = 4;
    imageSwap(mat, n);
    printMatrix(mat, n);
 
# This code is contributed by Rajput-Ji",quadratic,quadratic,quadratic,1,quadratic
115,"# Python3 program to find number
# of possible moves of knight
n = 4;
m = 4;
 
# To calculate possible moves
def findPossibleMoves(mat, p, q):
    global n, m;
     
    # All possible moves of a knight
    X = [2, 1, -1, -2, -2, -1, 1, 2];
    Y = [1, 2, 2, 1, -1, -2, -2, -1];
 
    count = 0;
 
    # Check if each possible move
    # is valid or not
    for i in range(8):
         
        # Position of knight after move
        x = p + X[i];
        y = q + Y[i];
 
        # count valid moves
        if(x >= 0 and y >= 0 and x < n and
           y < m and mat[x][y] == 0):
            count += 1;
 
    # Return number of possible moves
    return count;
 
# Driver code
if __name__ == '__main__':
    mat = [[1, 0, 1, 0], [0, 1, 1, 1],
           [1, 1, 0, 1], [0, 1, 1, 1]];
 
    p, q = 2, 2;
 
    print(findPossibleMoves(mat, p, q));
 
# This code is contributed by 29AjayKumar",constant,quadratic,quadratic,0,quadratic
116,"# A Naive method to find maximum
# value of mat[d][e] - mat[a][b]
# such that d > a and e > b
N = 5
 
# The function returns maximum
# value A(d,e) - A(a,b) over
# all choices of indexes such
# that both d > a and e > b.
def findMaxValue(mat):
     
    # stores maximum value
    maxValue = 0
 
    # Consider all possible pairs
    # mat[a][b] and mat[d][e]
    for a in range(N - 1):
        for b in range(N - 1):
            for d in range(a + 1, N):
                for e in range(b + 1, N):
                    if maxValue < int (mat[d][e] -
                                       mat[a][b]):
                        maxValue = int(mat[d][e] -
                                       mat[a][b]);
 
    return maxValue;
 
# Driver Code
mat = [[ 1, 2, -1, -4, -20 ],
       [ -8, -3, 4, 2, 1 ],
       [ 3, 8, 6, 1, 3 ],
       [ -4, -1, 1, 7, -6 ],
       [ 0, -4, 10, -5, 1 ]];
        
print(""Maximum Value is "" +
       str(findMaxValue(mat)))
       
# This code is contributed
# by ChitraNayal",np,nlogn,nlogn,0,nlogn
117,"# Python3 implementation of the approach
 
# A structure to represent a cell index
class Cell:
 
    def __init__(self, r, c):
        self.r = r # r is row, varies from 0 to R-1
        self.c = c # c is column, varies from 0 to C-1
 
# A simple solution to find sums
# for a given array of cell indexes
def printSums(mat, arr, n):
 
    # Iterate through all cell indexes
    for i in range(0, n):
     
        Sum = 0; r = arr[i].r; c = arr[i].c
 
        # Compute sum for current cell index
        for j in range(0, R):
            for k in range(0, C):
                if j != r and k != c:
                    Sum += mat[j][k]
        print(Sum)
 
# Driver Code
if __name__ == ""__main__"":
 
    mat = [[1, 1, 2], [3, 4, 6], [5, 3, 2]]
    R = C = 3
    arr = [Cell(0, 0), Cell(1, 1), Cell(0, 1)]
    n = len(arr)
    printSums(mat, arr, n)
     
# This code is contributed by Rituraj Jain",cubic,quadratic,quadratic,0,quadratic
118,"# Function Generate two output strings depending upon
# occurrence of character in input string
 
from collections import Counter
 
def generateStrings(input):
     
    # convert string into dictionary
    # having characters as keys and frequency as value
    freqDict = Counter(input)
 
    # separate out characters having frequency 1 and more than 1
    freq1 = [ key for (key,count) in freqDict.items() if count==1]
    freqMore1 = [ key for (key,count) in freqDict.items() if count>1]
 
    # sort lists and concatenate characters
    # with out space to print resultant strings
    freq1.sort()
    freqMore1.sort()
 
    # print output strings
    print ('String with characters occurring once:')
    print (''.join(freq1))
    print ('String with characters occurring multiple times:')
    print (''.join(freqMore1))
 
# Driver program
if __name__ == ""__main__"":
    input = ""geeksforgeeks""
    generateStrings(input)",nlogn,quadratic,quadratic,0,quadratic
119,"# Python code for the above approach
 
# this is function for finding sum of two
# numbers as string
def string_sum(str1, str2):
 
    if (len(str1) < len(str2)):
        str1, str2 = str2,str1
 
    m = len(str1)
    n = len(str2)
    ans = """"
 
    # sum the str2 with str1
    carry = 0
    for i in range(n):
 
        # Sum of current digits
        ds = ((ord(str1[m - 1 - i]) - ord('0')) +
                (ord(str2[n - 1 - i]) - ord('0')) +
                carry) % 10
 
        carry = ((ord(str1[m - 1 - i]) - ord('0')) +
                (ord(str2[n - 1 - i]) - ord('0')) +
                carry) // 10
 
        ans = str(ds) + ans
 
    for i in range(n,m):
        ds = (ord(str1[m - 1 - i]) - ord('0') +
                carry) % 10
        carry = (ord(str1[m - 1 - i]) - ord('0') +
                carry) // 10
        ans = str(ds) + ans
 
    if (carry):
        ans = str(carry) + ans
    return ans
 
# Returns True if two substrings of given
# lengths of str[beg..] can cause a positive
# result.
def checkSumStrUtil(Str, beg,len1, len2):
 
    # Finding two substrings of given lengths
    # and their sum
    s1 = Str[beg: beg+len1]
    s2 = Str[beg + len1: beg + len1 +len2]
    s3 = string_sum(s1, s2)
 
    s3_len = len(s3)
 
    # if number of digits s3 is greater than
    # the available string size
    if (s3_len > len(Str) - len1 - len2 - beg):
        return False
 
    # we got s3 as next number in main string
    if (s3 == Str[beg + len1 + len2: beg + len1 + len2 +s3_len]):
 
        # if we reach at the end of the string
        if (beg + len1 + len2 + s3_len == len(Str)):
            return True
 
        # otherwise call recursively for n2, s3
        return checkSumStrUtil(Str, beg + len1, len2,s3_len)
 
    # we do not get s3 in main string
    return False
 
# Returns True if str is sum string, else False.
def isSumStr(Str):
 
    n = len(Str)
 
    # choosing first two numbers and checking
    # whether it is sum-string or not.
    for i in range(1,n):
        for j in range(1,n-i):
            if (checkSumStrUtil(Str, 0, i, j)):
                return True
 
    return False
 
 
# Driver code
print(isSumStr(""1212243660""))
print(isSumStr(""123456787""))
 
# This code is contributed by shinjanpatra",cubic,nlogn,nlogn,0,nlogn
120,"# Python 3 program to find
# if a number is divisible
# by 4 or not
 
# Function to find that
# number divisible by
# 4 or not
def check(st):
    n = len(st)
 
    # Empty string
    if (n == 0):
        return False
 
    # int(string_variable) is used in Python3
    # to convert string to integer
 
    # If there is single
    # digit
    if (n == 1):
        return (int(st) % 4 == 0)
 
    # slicing of strings is used in Python to function as substring
    st = st[n-2:]
    # If number formed by
    # last two digits is
    # divisible by 4.
    return (int(st) % 4 == 0)
 
 
# Driver code
st = ""76952""
 
# Function call
if(check(st)):
    print(""Yes"")
else:
    print(""No "")
 
# This code is contributed by Abhijeet Kumar(abhijeet19403)",constant,quadratic,quadratic,0,quadratic
121,"# A Python3 code program
# to check for even or odd
 
# Returns true if n is even, else odd
def isEven(n):
     
    # n&1 is 1, then odd, else even
    return (not(n & 1))
     
# Driver code
n = 101;
print(""Even"" if isEven(n) else ""Odd"")
 
# This code is contributed by ""Sharad_Bhardwaj"".",constant,linear,linear,0,linear
122,"from collections import defaultdict
 
 
def have_same_frequency(freq: defaultdict, k: int):
    return all([freq[i] == k or freq[i] == 0 for i in freq])
 
 
def count_substrings(s: str, k: int) -> int:
    count = 0
    distinct = len(set([i for i in s]))
    for length in range(1, distinct + 1):
        window_length = length * k
        freq = defaultdict(int)
        window_start = 0
        window_end = window_start + window_length - 1
        for i in range(window_start, min(window_end + 1, len(s))):
            freq[s[i]] += 1
        while window_end < len(s):
            if have_same_frequency(freq, k):
                count += 1
            freq[s[window_start]] -= 1
            window_start += 1
            window_end += 1
            if window_end < len(s):
                freq[s[window_end]] += 1
    return count
 
 
if __name__ == '__main__':
    s = ""aabbcc""
    k = 2
    print(count_substrings(s, k))
    s = ""aabbc""
    k = 2
    print(count_substrings(s, k))",quadratic,nlogn,nlogn,0,nlogn
123,"# Python3 program to get number of ways to increase
# LCS by 1
 
M = 26
 
# Method returns total ways to increase LCS length by 1
def waysToIncreaseLCSBy1(str1, str2):
    m = len(str1)
    n = len(str2)
 
    # Fill positions of each character in vector
    # vector<int> position[M];
    position = [[] for i in range(M)]
    for i in range(1, n+1, 1):
        position[ord(str2[i-1])-97].append(i)
 
    # Initializing 2D array by 0 values
    lcsl = [[0 for i in range(n+2)] for j in range(m+2)]
    lcsr = [[0 for i in range(n+2)] for j in range(m+2)]
 
    # Filling LCS array for prefix substrings
    for i in range(1, m+1, 1):
        for j in range(1, n+1,1):
            if (str1[i-1] == str2[j-1]):
                lcsl[i][j] = 1 + lcsl[i-1][j-1]
            else:
                lcsl[i][j] = max(lcsl[i-1][j],
                                lcsl[i][j-1])
 
    # Filling LCS array for suffix substrings
    for i in range(m, 0, -1):
        for j in range(n, 0, -1):
            if (str1[i-1] == str2[j-1]):
                lcsr[i][j] = 1 + lcsr[i+1][j+1]
            else:
                lcsr[i][j] = max(lcsr[i+1][j],
                                lcsr[i][j+1])
 
        # Looping for all possible insertion positions
        # in first string
    ways = 0
    for i in range(0, m+1,1):
        # Trying all possible lower case characters
        for C in range(0, 26,1):
            # Now for each character, loop over same
            # character positions in second string
            for j in range(0, len(position[C]),1):
                p = position[C][j]
 
                # If both, left and right substrings make
                # total LCS then increase result by 1
                if (lcsl[i][p-1] + lcsr[i+1][p+1] == lcsl[m][n]):
                    ways += 1
    return ways
 
 
# Driver code to test above methods
str1 = ""abcabc""
str2 = ""abcd""
print(waysToIncreaseLCSBy1(str1, str2))
 
# This code is contributed by ankush_953",quadratic,nlogn,nlogn,0,nlogn
124,"# Python3 program for above approach
 
# Returns count of distinct 
# subsequences of str.
def countSub(s):
     
    Map = {}
 
    # Iterate from 0 to length of s
    for i in range(len(s)):
        Map[s[i]] = -1
 
    allCount = 0
    levelCount = 0
 
    # Iterate from 0 to length of s
    for i in range(len(s)):
        c = s[i]
 
        # Check if i equal to 0
        if (i == 0):
            allCount = 1
            Map = 1
            levelCount = 1
            continue
 
        # Replace levelCount with
          # allCount + 1
        levelCount = allCount + 1
 
        # If map is less than 0
        if (Map < 0):
            allCount = allCount + levelCount
        else:
            allCount = allCount + levelCount - Map
 
        Map = levelCount
 
    # Return answer
    return allCount
 
# Driver Code
List = [ ""abab"", ""gfg"" ]
 
for s in List:
    cnt = countSub(s)
    withEmptyString = cnt + 1
 
    print(""With empty string count for"",
          s, ""is"", withEmptyString)
    print(""Without empty string count for"",
          s, ""is"", cnt)
 
# This code is contributed by rag2127",linear,n,linear,1,n
125,"# A simple recursive Python
# program to find shortest
# uncommon subsequence.
MAX = 1005
 
# A recursive function to
# find the length of shortest
# uncommon subsequence
def shortestSeq(S, T, m, n):
 
    # S String is empty
    if m == 0:
        return MAX
 
    # T String is empty
    if(n <= 0):
        return 1
 
    # Loop to search for
    # current character
    for k in range(n):
        if(T[k] == S[0]):
            break
 
    # char not found in T
    if(k == n):
        return 1
 
    # Return minimum of following
    # two Not including current
    # char in answer Including
    # current char
    return min(shortestSeq(S[1 : ], T, m - 1, n),
               1 + shortestSeq((S[1 : ]), T[k + 1 : ],
                                m - 1, n - k - 1))
 
# Driver code
S = ""babab""
T = ""babba""
 
m = len(S)
n = len(T)
ans = shortestSeq(S, T, m, n)
if(ans >= MAX):
    ans =- 1
print(""Length of shortest subsequence is:"", ans)
 
# This code is contributed by avanitrachhadiya2155",cubic,n,linear,0,n
126,"# Python3 program to check if all rows
# of a matrix are rotations of each other
 
MAX = 1000
 
# Returns true if all rows of mat[0..n-1][0..n-1]
# are rotations of each other.
def isPermutedMatrix(mat, n) :
     
    # Creating a string that contains
    # elements of first row.
    str_cat = """"
    for i in range(n) :
        str_cat = str_cat + ""-"" + str(mat[0][i])
 
    # Concatenating the string with itself
    # so that substring search operations
    # can be performed on this
    str_cat = str_cat + str_cat
 
    # Start traversing remaining rows
    for i in range(1, n) :
         
        # Store the matrix into vector
        # in the form of strings
        curr_str = """"
         
        for j in range(n) :
            curr_str = curr_str + ""-"" + str(mat[i][j])
 
        # Check if the current string is present
        # in the concatenated string or not
        if (str_cat.find(curr_str)) :
            return True
             
    return False
 
# Driver code
if __name__ == ""__main__"" :
    n = 4
    mat = [[1, 2, 3, 4],
           [4, 1, 2, 3],
           [3, 4, 1, 2],
           [2, 3, 4, 1]]
     
    if (isPermutedMatrix(mat, n)):
        print(""Yes"")
    else :
        print(""No"")
         
# This code is contributed by Ryuga",cubic,quadratic,quadratic,0,quadratic
127,"# Python3 program to implement binary search
#  in a sparse array
 
def sparseSearch(arr , key , low , high):
 
    left = 0; right = 0
 
    while low <= high:
 
            mid = low + (high - low) // 2
 
            if arr[mid] == '':
                left = mid - 1
                right = mid + 1
 
                while True:
 
                    # Check for out of bounds
                    if left < low and right > high:
                        return -1
 
                    elif left >= low and arr[left] != '':
                        # Search left
                        mid = left
                        break
 
                    elif right <= high and arr[right] != '':
                        # Search right
                        mid = right
                        break
 
                    left -= 1
                    right += 1
 
            if arr[mid] == key:
                print('Found string {} at index {}'.format
                     (arr[mid] , mid))
                return mid
 
            # Classical Binary search
            # search left
            elif arr[mid] > key:
                high = mid - 1
 
            # search right
            elif arr[mid] < key:
                low = mid + 1
 
    return -1
 
if __name__ == '__main__':
 
    arr = [""for"", ""geeks"", """", """", """", """", ""ide"",
           ""practice"", """", """", """", ""quiz""]                
    key = 'geeks'
 
    low = 0
    high = len(arr) - 1
 
    sparseSearch(arr , key , low , high)
 
# This is  Code contributed by
# Ashwin Viswanathan
# Additional Updates by Meghna Natraj",logn,quadratic,quadratic,0,quadratic
128,"# Finds maximum occurring digit
# without using any array/string
 
# Simple function to count
# occurrences of digit d in x
def countOccurrences(x, d):
    count = 0; # Initialize count
               # of digit d
    while (x):
         
        # Increment count if current
        # digit is same as d
        if (x % 10 == d):
            count += 1;
        x = int(x / 10);
 
    return count;
 
# Returns the max occurring
# digit in x
def maxOccurring(x):
     
    # Handle negative number
    if (x < 0):
        x = -x;
     
    result = 0; # Initialize result
                # which is a digit
    max_count = 1; # Initialize count
                   # of result
     
    # Traverse through all digits
    for d in range(10):
         
        # Count occurrences of current digit
        count = countOccurrences(x, d);
         
        # Update max_count and
        # result if needed
        if (count >= max_count):
            max_count = count;
            result = d;
         
    return result;
 
# Driver Code
x = 1223355;
print(""Max occurring digit is"",
              maxOccurring(x));
 
# This code is contributed by mits.",constant,n,linear,0,n
129,"# A simple Python program to check if binary
# representations of two numbers are anagram.
SIZE = 8
def bit_anagram_check(a, b):
 
    # Find reverse binary representation of a
    # and store it in binary_a[]
    global size
 
    i = 0
    binary_a = [0] * SIZE
    while (a > 0):
        binary_a[i] = a % 2
        a //= 2
        i += 1
 
    # Find reverse binary representation of b
    # and store it in binary_a[]
    j = 0
    binary_b = [0] * SIZE
    while (b > 0):
        binary_b[j] = b % 2
        b //= 2
        j += 1
 
    # Sort two binary representations
    binary_a.sort()
    binary_b.sort()
 
    # Compare two sorted binary representations
    for i in range(SIZE):
        if (binary_a[i] != binary_b[i]):
            return 0
    return 1
 
# Driver code
if __name__ == ""__main__"":
 
    a = 8
    b = 4
    print(bit_anagram_check(a, b))
 
    # This code is contributed by ukasp.",constant,quadratic,quadratic,0,quadratic
130,"# Python3 program to count total anagram
# substring of a string
def countOfAnagramSubstring(s):
     
    # Returns total number of anagram
    # substrings in s
    n = len(s)
    mp = dict()
     
    # loop for length of substring
    for i in range(n):
        sb = ''
        for j in range(i, n):
            sb = ''.join(sorted(sb + s[j]))
            mp[sb] = mp.get(sb, 0)
             
            # increase count corresponding
            # to this dict array
            mp[sb] += 1
 
    anas = 0
     
    # loop over all different dictionary
    # items and aggregate substring count
    for k, v in mp.items():
        anas += (v*(v-1))//2
    return anas
 
# Driver Code
s = ""xyyx""
print(countOfAnagramSubstring(s))
 
# This code is contributed by fgaim",quadratic,nlogn,nlogn,0,nlogn
131,"# Python3 implementation of above idea
  
# A function to check if n is palindrome
def isPalindrome(n: int) -> bool:
  
    # Find reverse of n
    rev = 0
    i = n
    while i > 0:
        rev = rev * 10 + i % 10
        i //= 10
  
    # If n and rev are same, 
    # then n is palindrome
    return (n == rev)
  
# prints palindrome between min and max
def countPal(minn: int, maxx: int) -> None:
    for i in range(minn, maxx + 1):
        if isPalindrome(i):
            print(i, end = "" "")
  
# Driver Code
if __name__ == ""__main__"":
    countPal(100, 2000)
  
# This code is contributed by
# sanjeev2552",logn,quadratic,quadratic,0,quadratic
132,"# Recursive Python program to generate all
# binary strings formed by replacing
# each wildcard character by 0 or 1
 
# Recursive function to generate all binary
# strings formed by replacing each wildcard
# character by 0 or 1
def _print(string, index):
    if index == len(string):
        print(''.join(string))
        return
 
    if string[index] == ""?"":
 
        # replace '?' by '0' and recurse
        string[index] = '0'
        _print(string, index + 1)
 
        # replace '?' by '1' and recurse
        string[index] = '1'
        _print(string, index + 1)
 
        # NOTE: Need to backtrack as string
        # is passed by reference to the
        # function
        string[index] = '?'
    else:
        _print(string, index + 1)
 
# Driver code
if __name__ == ""__main__"":
 
    string = ""1??0?101""
    string = list(string)
    _print(string, 0)
 
    # This code is contributed by
    # sanjeev2552
 
# Note: function name _print is used because
# print is already a predefined function in Python",np,quadratic,quadratic,0,quadratic
133,"def All_Binary_Strings(arr,num,r):
 
    if(r == num):
 
        for i in range(num):
            print(arr[i],end="""")
        print(end="" "")
        return
     
    elif(arr[r-1]):
 
        arr[r] = 0
        All_Binary_Strings(arr, num, r + 1)
 
    else:
     
        arr[r] = 0
        All_Binary_Strings(arr,num,r+1)
        arr[r] = 1
        All_Binary_Strings(arr,num,r+1)
 
 
def Print(a,num):
    a[0] = 0
    All_Binary_Strings(a,num,1)
    a[0] = 1
    All_Binary_Strings(a,num,1)
 
 
# driver's code
 
n = 2
a = [False for i in range(n)]
Print(a,n)
 
# This code is contributed by shinjanpatra",np,quadratic,quadratic,0,quadratic
134,"# Python3 program to generate n-bit Gray codes
import math as mt
 
# This function generates all n bit Gray
# codes and prints the generated codes
def generateGrayarr(n):
 
    # base case
    if (n <= 0):
        return
 
    # 'arr' will store all generated codes
    arr = list()
 
    # start with one-bit pattern
    arr.append(""0"")
    arr.append(""1"")
 
    # Every iteration of this loop generates
    # 2*i codes from previously generated i codes.
    i = 2
    j = 0
    while(True):
 
        if i >= 1 << n:
            break
     
        # Enter the previously generated codes
        # again in arr[] in reverse order.
        # Nor arr[] has double number of codes.
        for j in range(i - 1, -1, -1):
            arr.append(arr[j])
 
        # append 0 to the first half
        for j in range(i):
            arr[j] = ""0"" + arr[j]
 
        # append 1 to the second half
        for j in range(i, 2 * i):
            arr[j] = ""1"" + arr[j]
        i = i << 1
 
    # print contents of arr[]
    for i in range(len(arr)):
        print(arr[i])
 
# Driver Code
generateGrayarr(3)
 
# This code is contributed
# by Mohit kumar 29",np,quadratic,quadratic,0,quadratic
135,"# Python3 implementation of the above approach
def GreyCode(n):
 
    # power of 2
    for i in range(1 << n):
       
        # Generating the decimal
        # values of gray code then using
        # bitset to convert them to binary form
        val = (i ^ (i >> 1))
         
        # Converting to binary string
        s = bin(val)[2::]
        print(s.zfill(n), end = "" "")
 
# Driver Code
n = 4
   
# Function call
GreyCode(n)
 
# This code is contributed by phasing17",np,quadratic,quadratic,0,quadratic
136,"# Python program to find lexicographic
# rank of a string
 
# A utility function to find factorial
# of n
def fact(n):
    f = 1
    while n >= 1:
        f = f * n
        n = n - 1
    return f
 
# A utility function to count smaller
# characters on right of arr[low]
def findSmallerInRight(st, low, high):
    countRight = 0
    i = low + 1
    while i <= high:
        if st[i] < st[low]:
            countRight = countRight + 1
        i = i + 1
 
    return countRight
 
# A function to find rank of a string
# in all permutations of characters
def findRank(st):
    ln = len(st)
    mul = fact(ln)
    rank = 1
    i = 0
 
    while i < ln:
        mul = mul // (ln - i)
 
        # count number of chars smaller
        # than str[i] from str[i + 1] to
        # str[len-1]
        countRight = findSmallerInRight(st, i, ln-1)
 
        rank = rank + countRight * mul
        i = i + 1
 
    return rank
 
 
# Driver code
if __name__ == '__main__':
    st = ""string""
     
    # Function call
    print(findRank(st))
 
# This code is contributed by Nikita Tiwari.",quadratic,nlogn,nlogn,0,nlogn
137,"# Python3 program to check if we can
# break a into four distinct strings.
 
# Return if the given string can be
# split or not.
def check(s):
 
    # We can always break a of size 10 or
    # more into four distinct strings.
    if (len(s) >= 10):
        return True
 
    # Brute Force
    for i in range(1, len(s)):
     
        for j in range(i + 1, len(s)):
         
            for k in range(j + 1, len(s)):
             
                # Making 4 from the given
                s1 = s[0:i]
                s2 = s[i:j - i]
                s3 = s[j: k - j]
                s4 = s[k: len(s) - k]
                 
                # Checking if they are distinct or not.
                if (s1 != s2 and s1 != s3 and s1 != s4 and
                    s2 != s3 and s2 != s4 and s3 != s4):
                    return True
             
    return False
 
# Driver Code
if __name__ == '__main__':
    str = ""aaabb""
 
    print(""Yes"") if(check(str)) else print(""NO"")
 
# This code is contributed
# by SHUBHAMSINGH10",np,quadratic,quadratic,0,quadratic
138,"# A recursive program to print all possible
# partitions of a given string into dictionary
# words
 
# A utility function to check whether a word
# is present in dictionary or not.  An array of
# strings is used for dictionary.  Using array
# of strings for dictionary is definitely not
# a good idea. We have used for simplicity of
# the program
def dictionaryContains(word):
    dictionary = {""mobile"", ""samsung"", ""sam"", ""sung"", ""man"",
                  ""mango"", ""icecream"", ""and"", ""go"", ""i"", ""love"", ""ice"", ""cream""}
    return word in dictionary
 
# Prints all possible word breaks of given string
def wordBreak(string):
   
    # Last argument is prefix
    wordBreakUtil(string, len(string), """")
 
# Result store the current prefix with spaces
# between words
def wordBreakUtil(string, n, result):
 
    # Process all prefixes one by one
    for i in range(1, n + 1):
       
        # Extract substring from 0 to i in prefix
        prefix = string[:i]
         
        # If dictionary contains this prefix, then
        # we check for remaining string. Otherwise
        # we ignore this prefix (there is no else for
        # this if) and try next
        if dictionaryContains(prefix):
           
            # If no more elements are there, print it
            if i == n:
 
                # Add this element to previous prefix
                result += prefix
                print(result)
                return
            wordBreakUtil(string[i:], n - i, result+prefix+"" "")
 
# Driver Code
if __name__ == ""__main__"":
    print(""First Test:"")
    wordBreak(""iloveicecreamandmango"")
 
    print(""\nSecond Test:"")
    wordBreak(""ilovesamsungmobile"")
 
# This code is contributed by harshitkap00r",np,n,linear,0,n
139,"# Python3 program to implement the approach
 
# Python3 has no built-in swap function.
def swap(str, i, j):
    ch = list(str)
    temp = ch[i]
    ch[i] = ch[j]
    ch[j] = temp
    return """".join(ch)
 
# Since STRINGS are immutable in JavaScript, first we have
# to convert it to a character array in order to sort.
def sortString(str, s_index, e_index):
    tempArray = list(str)
 
    # Sorting temp array using
    tempArray = tempArray[:s_index] + sorted(tempArray[s_index: e_index])
 
    # returning the new sorted string
    return """".join(tempArray)
 
def maximizeNumber(N, M):
    # Sorting the digits of the
    # number in increasing order.
    N = sortString(N, 0, len(N))
 
    for i in range(len(N)):
        for j in range(i + 1, len(N)):
 
            # Copying the string into another
            # temp string.
            t = N
 
            # Swapping the j-th char(digit)
            # with i-th char(digit)
 
            t = swap(t, j, i)
 
            # Sorting the temp string
            # from i-th pos to end.
            t = sortString(t, i + 1, len(t))
 
            # Checking if the string t is
            # greater than string N and less
            # than or equal to the number M.
            if (int(t) > int(N) and int(t) <= M):
 
                # If yes then, we will permanently
                # swap the i-th char(or digit)
                # with j-th char(digit).
                N = swap(N, i, j)
 
    # Returns the maximized number.
    return N
 
# Driver Code
N = ""123""
M = 222
print(maximizeNumber(N, M))
 
# This code is contributed by phasing17",cubic,nlogn,nlogn,0,nlogn
